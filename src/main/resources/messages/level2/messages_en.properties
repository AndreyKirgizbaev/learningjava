#part1
levels.level2.part1=String
levels.level2.part1.string=The String type
levels.level2.part1.string.about1=<code>String</code> is a reference type consisting of characters. \
  It is one of the most widely used types in Java. Here is an example of a string: <code>"Hello, Java"</code>. \
  This string is a sequence of 11 characters, including one space.
levels.level2.part1.string.about2=This type has some features:
levels.level2.part1.string.about3=<b>immutable type</b>: it's impossible to change a character in a string;
levels.level2.part1.string.about4=it has methods for getting individual characters and extracting substrings;
levels.level2.part1.string.about5=individual characters can be accessed by indexes, \
  the first character has the index <b>0</b>, the last one – <b>the length of the string</b> – <b>1</b>;
levels.level2.part1.string.about6=non-primitive type.
levels.level2.part1.createString=Creating strings
levels.level2.part1.createString.about1=A string literal is surrounded by a pair of double quotes, for instance:
levels.level2.part1.createString.about2=String simpleString = "It is a simple string"; // a simple string\n\
  System.out.println(simpleString);  // it prints "It is a simple string"\n\
  \n\
  String anotherString = "This is\\na multiple\\nstring"; // a string with escape sequences\n\
  System.out.println(anotherString); // it prints the result in several lines
levels.level2.part1.createString.about3=A string can represent a long character sequence (text). \
  A string can have one or zero characters.
levels.level2.part1.createString.about4=String strangeText = "aaaaaaaaaaaassssssssssss gggggggggggggggggggg ddddddddddd qqqqqq ffff";\n\
  \n\
  String emptyString = "";\n\
  \n\
  String s = "s"; // a string consisting of one character
levels.level2.part1.createString.about5=A string can be null. It means no value assigned.
levels.level2.part1.createString.about6=String nullString = null; // it is null
levels.level2.part1.createString.about7=Another way to create a variable of  String is by using \
  the keyword <code>new</code>.
levels.level2.part1.createString.about8=String str = new String("my-string"); \
  // it creates an object and assigns it to the variable
levels.level2.part1.length=Get the length and characters of a string
levels.level2.part1.length.about1=Any string has two useful methods:
levels.level2.part1.length.about2=<code>length()</code> returns the number of characters in the string;
levels.level2.part1.length.about3=<code>charAt(int index)</code> returns a character by its index;
levels.level2.part1.length.about4=Here is an example:
levels.level2.part1.length.about5=String s = "Hi, all";\n\
  \n\
  int len = s.length(); // the len is 7\n\
  \n\
  char theFirstChar = s.charAt(0);  // 'H' has the index 0\n\
  \n\
  char theFifthChar = s.charAt(4); // 'a' has the index 4\n\
  \n\
  char theLastChar = s.charAt(s.length() - 1); // 'l' has the index 6
levels.level2.part1.length.about6=You can easily get a character of a string by the index, \
  but you can't change characters because strings are immutable in Java.
levels.level2.part1.useful=Useful methods of strings
levels.level2.part1.useful.about1=The standard library of Java provides a lot of useful methods for processing strings:
levels.level2.part1.useful.about2=<code>isEmpty()</code> returns <code>true</code> if the string is empty, \
  otherwise – <code>false</code>;
levels.level2.part1.useful.about3=<code>toUpperCase()</code> returns a new string in uppercase;
levels.level2.part1.useful.about4=<code>toLowerCase()</code> returns a new string in lowercase;
levels.level2.part1.useful.about5=<code>startsWith(prefix)</code> returns <code>true</code> \
  if the string starts with the given string prefix, otherwise -<code>false</code>;
levels.level2.part1.useful.about6=<code>endsWith(suffix)</code> returns <code>true</code> \
  if the string ends with the given string suffix, otherwise, <code>false</code>.
levels.level2.part1.useful.about7=<code>contains(...)</code> returns true if the string contains the given string or character;
levels.level2.part1.useful.about8=<code>substring(beginIndex, endIndex)</code> returns a substring of the string in the range: \
  <code>beginIndex</code>, <code>endIndex - 1</code>;
levels.level2.part1.useful.about9=<code>replace(old, new)</code> returns a new string obtained by replacing all occurrences \
  of <code>old</code> with <code>new</code> that can be chars or strings.
levels.level2.part1.useful.about10=<code>trim()</code> returns a copy of the string obtained by omitting the \
  leading and trailing whitespace. Note that whitespace includes not only space character, \
  but mostly everything that looks empty: tab, carriage return, newline character, etc.
levels.level2.part1.useful.about11=See the following example to better understand these methods:
levels.level2.part1.useful.about12=String text = "The simple text string";\n\
  \n\
  boolean empty = text.isEmpty(); // false\n\
  \n\
  String textInUpperCase = text.toUpperCase(); // "THE SIMPLE TEXT STRING"\n\
  \n\
  boolean startsWith = textInUpperCase.startsWith("THE"); // true\n\
  \n\
  /* replace all whitespaces with empty strings */\n\
  \n\
  String noWhitespaces = textInUpperCase.replace(" ", ""); // "THESIMPLETEXTSTRING"\n\
  \n\
  String textWithWhitespaces = "\t text with whitespaces   !\n  \t";\n\
  \n\
  String trimmedText = textWithWhitespaces.trim(); // "text with whitespaces   !"
levels.level2.part1.exceptions=Exceptions when processing strings
levels.level2.part1.exceptions.about1=When working with strings, there can be several exceptions.
levels.level2.part1.exceptions.about2=1. <code>NullPointerException</code>. \
  If a string is <code>null</code> and you call a method of the string, it throws <code>NullPointerException</code>.
levels.level2.part1.exceptions.about3=String s = null;\n\
  int length = s.length(); // it throws NullPointerException
levels.level2.part1.exceptions.about4=2. <code>StringIndexOutOfBoundsException</code>. \
  If you try to access a non-existing character by an index then this exception occurs.
levels.level2.part1.exceptions.about5=String s = "ab";\n\
  char c = s.charAt(2); // it throws StringIndexOutOfBoundsException because indexing starts with 0
levels.level2.part1.exceptions.about6=We will consider how to handle different types of exceptions later.
levels.level2.part1.concatenating=Concatenating strings
levels.level2.part1.concatenating.about1=Two strings can be concatenated using the "+" operator \
  or the <code>concat</code> method. Both approaches lead to the same results.
levels.level2.part1.concatenating.about2=String firstName = "John";\n\
  String lastName = "Smith";\n\
  \n\
  // concatenation using the "+" operator\n\
  String fullName1 = firstName + " " + lastName; // "John Smith"\n\
  \n\
  // concatenation using the concat method\n\
  String fullName2 = firstName.concat(" ").concat(lastName); // "John Smith"
levels.level2.part1.concatenating.about3=When we concatenate two strings a new string is created (because strings are immutable).
levels.level2.part1.concatenating.about4=Important: in the general case <code>str1 + str2</code> \
  is not the same as <code>str2 + str1</code> because the concatenation is not a commutative operation.
levels.level2.part1.appending=Appending values to a string
levels.level2.part1.appending.about1=It's possible to add values of different types to a string. \
  The value will be automatically converted to a string. See an example below.
levels.level2.part1.appending.about2=String str = "str" + 10 + false; // the result is "str10false"
levels.level2.part1.appending.about3=In the example above, the order of execution is:
levels.level2.part1.appending.about4="str" + 10 => "str10"
levels.level2.part1.appending.about5="str10" + false = "str10false"
levels.level2.part1.appending.about6=Let's see more complex example:
levels.level2.part1.appending.about7=String shortString = "str";\n\
  long number = 100;\n\
  \n\
  String result1 = shortString + number + 50; // the result is "str10050"\n\
  String result2 = number + 50 + shortString; // what is the result2?
levels.level2.part1.appending.about8=The <code>result2</code> is <code>150str</code>, because, first, \
  we calculate a sum of <code>number</code> and <code>50</code> and then <code>concat</code> it with <code>str</code>. \
  The order of operations is important.
levels.level2.part1.compare=How to compare strings correctly?
levels.level2.part1.compare.about1=Since <code>String</code> is a reference type you shouldn't \
  compare strings using <code>==</code> or <code>!=</code> operators. \
  In this case, only addresses will be compared, but not actual values.
levels.level2.part1.compare.about2=<code>String</code> has two convenient methods for comparing \
  the equivalence of the actual content of one string with the content of another string: \
  <code>equals(other)</code> and <code>equalsIgnoreCase(other)</code>. See an example below.
levels.level2.part1.compare.about3=String first = "first";\n\
  String second = "second";\n\
  \n\
  String anotherFirst = "first";\n\
  String secondInUpperCase = "SECOND";\n\
  \n\
  System.out.println(first.equals(second)); // false, the strings have different values\n\
  System.out.println(first.equals(anotherFirst)); // true, the strings have the same value\n\
  \n\
  System.out.println(second.equals(secondInUpperCase)); // false, the strings have different cases\n\
  System.out.println(second.equalsIgnoreCase(secondInUpperCase)); // true, it ignores cases
levels.level2.part1.compare.about4=Do not forget the rules when comparing strings.
levels.level2.part1.task=Create the string<b>str</b> and set it to "Java is the best!". \
  Display 9 and 5 characters on the screen (remember that the index starts at 0).
levels.level2.part1.task.about=hi
levels.level2.part1.task.error1=You did not declare the string str!
levels.level2.part1.task.error2=You have not assigned a value to the string str!
levels.level2.part1.task.error3=You do not print 9 character!
levels.level2.part1.task.error4=You do not display 5 character!
levels.level2.part1.task.error5=Do not change anything in main!
#part2
levels.level2.part2=Formatted output
levels.level2.part2.introduction=Introduction
levels.level2.part2.introduction.about1=You are already familiar with <code>System.out.print()</code> \
  and <code>System.out.println()</code> methods to print output to the console. \
  But when you need complex <b>formatting</b> of output, these two methods are not really helpful. \
  There are two methods that you can use in such cases. \
  Those are <code>System.out.printf()</code> and <code>String.format()</code>. \
  Let's discuss them in detail and focus on string and number formatting.
levels.level2.part2.printf=Introducing printf() method
levels.level2.part2.printf.about1=The <code>printf()</code> method usually has two parts. \
  First, you give the string you want to format as the first attribute. \
  This string itself includes rules to format it via <b>format - specifiers</b>. \
  Some examples of format specifiers are <code>%d</code>, <code>%s</code>, etc. \
  In the second part, you give the argument list that Java can use to format the string according to format-specifiers.
levels.level2.part2.printf.about2=See the following example to understand the different parts \
  of the <code>printf()</code> function.
levels.level2.part2.printf.about3=System.out.printf("My Name is %s. I was born in %d", "Mike", 1998);
levels.level2.part2.printf.about4=The first part is <code>"My Name is %s. I was born in %d"</code>
levels.level2.part2.printf.about5=<code>%s</code> and <code>%d</code> are the format specifiers.
levels.level2.part2.printf.about6=The second part is <code>"Mike",1998</code> which are argument list.
levels.level2.part2.use=Different use cases of printf()
levels.level2.part2.use.about1=It's time to know the different use cases of format-specifiers. \
  It's quite easy to understand with code samples. Let's try now.
levels.level2.part2.use.about2=You can display an integer with <code>%d</code> format specifier.
levels.level2.part2.use.about3=public static void main(String[] args){\n\
  \tSystem.out.printf("Display a Number %d", 15000);\n\
  }
levels.level2.part2.use.about4=Java will replace 15000 in place of <code>%d</code>. \
  The output of the above code is <code>Display a Number 15000</code>
levels.level2.part2.use.about5=if you want several integers to display in the output, use several <code>%d</code> specifiers.
levels.level2.part2.use.about6=public static void main(String[] args){\n\
  \tSystem.out.printf("Sum of %d and %d is %d", 15, 40, 55);\n\
  }
levels.level2.part2.use.about7=Java will replace each argument in place of <code>%d</code> respectively starting from left. \
  The output of the above code is <code>Sum of 15 and 40 is 55</code>
levels.level2.part2.use.about8=If you want to display a floating-point value use <code>%f</code> specifier.
levels.level2.part2.use.about9=public static void main(String[] args){\n\
  \tSystem.out.printf("Display a Number %f", 15.23);\n\
  }
levels.level2.part2.use.about10=Similar to the above cases, Java will replace 15.23 in place of <code>%f</code>. \
  The above code will produce the following output. <code>Display a Number 15.230000</code> \
  Although it's technically correct, it looks ugly. You don't want so many trailing zeros. \
  You can set <b>precision</b> with <code>printf()</code> method.
levels.level2.part2.use.about11=public static void main(String[] args){\n\
  \tSystem.out.printf("Display a Number %.2f", 15.23);\n\
  }
levels.level2.part2.use.about12=<code>.2f</code> decided that the number of digits that \
  should appear after the <b>decimal</b> place is two. \
  The code given above will output <code>Display a Number 15.23</code>
levels.level2.part2.use.about13=Similarly, you can display Characters and Strings with <code>printf()</code> method. \
  Look at the following code. If you want to print a character, use <code>%c</code> \
  and if you want to print a String, use <code>%s</code>.
levels.level2.part2.use.about14=public static void main(String[] args){\n\
  \tchar abbr = 'H';\n\
  \tString element = "Hydrogen";\n\
  \tSystem.out.printf("%c stands for %s", abbr, element);\n\
  }
levels.level2.part2.use.about15=When this code runs, the value of the <code>abbr</code> \
  variable will replace <code>%c</code> and value of the <code>element</code> will replace <code>%s</code>. \
  The output of the above code is <code>H stands for Hydrogen</code>. \
  That's all about <code>printf()</code> method. Let's move on to learn <code>String.format()</code> method.
levels.level2.part2.format=String.format() Method
levels.level2.part2.format.about1=The <code>format()</code> method in the <code>String</code> \
  class works very much like <code>printf()</code> method. \
  The main difference here is you return a string instead of printing it. Let's see several examples.
levels.level2.part2.format.about2=The following code formats an integer using it.
levels.level2.part2.format.about3=public static void main(String[] args){\n\
  \tint age = 22;\n\
  \tString str = String.format("My age is %d", age);\n\
  \tSystem.out.println(str);\n\
  }
levels.level2.part2.format.about4=When you execute this code, Java will create a String called <code>str</code> \
  by concatenating <code>My age is</code> with the value of the <code>age</code> variable. \
  Then it will print the value of <code>str</code>. The output is:
levels.level2.part2.format.about5=My age is 22
levels.level2.part2.format.about6=Similarly, you can format other data types as well. See the following code.
levels.level2.part2.format.about7=public static void main(String[] args){\n\
  \tint age = 22;\n\
  \tchar initial = 'M';\n\
  \tString surname = "Anderson";\n\
  \tdouble height = 1.72;\n\
  \n\
  \tString details = String.format("My name is %c. %s.%nMy age is %d.%nMy height is %.2f.", initial, surname, age, height);\n\
  \tSystem.out.println(details);\n\
  }
levels.level2.part2.format.about8=You can see that we have used four types of data types in my example. \
  Java will replace <code>%c, %s, %d, %f</code> with <code>initial, surname, age</code>, \
  and <code>height</code> respectively. <code>%n</code> <b>newline</b> character breaks \
  the line every time it was used. The output of our code is
levels.level2.part2.format.about9=My name is M. Anderson.\n\
  My age is 22.\n\
  My height is 1.72.
levels.level2.part2.summary=Summary
levels.level2.part2.summary.about1=Let's summarize what we learned in this topic.
levels.level2.part2.summary.about2=Format-Specifier
levels.level2.part2.summary.about3=datatype related
levels.level2.part2.summary.about4=Format printing
levels.level2.part2.summary.about5=Formatting a string
levels.level2.part2.summary.about6=%d
levels.level2.part2.summary.about7=int, short, byte, long
levels.level2.part2.summary.about8=System.out.printf("Display a Integer %d",15000);
levels.level2.part2.summary.about9=String.format("Display a Integer %d",15000)
levels.level2.part2.summary.about10=%c
levels.level2.part2.summary.about11=char
levels.level2.part2.summary.about12=System.out.printf("Display a Character %c",'c');
levels.level2.part2.summary.about13=String.format("Display a Character %c",'c')
levels.level2.part2.summary.about14=%f
levels.level2.part2.summary.about15=double, float
levels.level2.part2.summary.about16=System.out.printf("Display a Floating-point Number %f",123.45);
levels.level2.part2.summary.about17=String.format("Display a Floating-point Number %f",123.45)
levels.level2.part2.summary.about18=%s
levels.level2.part2.summary.about19=String
levels.level2.part2.summary.about20=System.out.printf("Display a String %s","String");
levels.level2.part2.summary.about21=String.format("Display a String %s","String")
levels.level2.part2.conclusion=Conclusion
levels.level2.part2.conclusion.about1=When you are writing complex applications combining strings \
  and variables with <code>+</code> sign is not recommended. \
  The <code>printf()</code> method and <code>format()</code> methods are specifically created for that. \
  Both these methods work exactly the same way apart from <code>printf()</code> method prints the output \
  while <code>format()</code> method returns a <code>String</code>. \
  In this article, you have learned most of the use cases of both the functions. Enjoy it.
levels.level2.part2.task=Declare the <b>lvl</b> variable and set it to 2. \
  Create a string <b>str</b> and set it to "My level in java = 2" using the String.format() method. \
  Display str.
levels.level2.part2.task.about=Мy level in java = 2
levels.level2.part2.task.error1=You did not declare the string str!
levels.level2.part2.task.error2=You have not assigned a value to the string str!
levels.level2.part2.task.error3=You have not declared the lvl variable!
levels.level2.part2.task.error4=You have not assigned a value to the lvl variable!
levels.level2.part2.task.error5=Do not change anything in main!
#part3
levels.level2.part3=Ternary operator
levels.level2.part3.about1=The <b>ternary operator</b> is an operator which evaluates a condition and \
  chooses one of two cases to execute. It is also called the <b>conditional operator</b>. \
  The operator can be considered as a form of the <code>if</code>-then-<code>else</code> statement. \
  The ternary operator should not be confused with the conditional statement, despite their ideological similarity. \
  This operator can be used in places where an expression is expected.
levels.level2.part3.about2=Sometimes the <b>ternary operator</b> is more readable and \
  concise than the corresponding <b>if statement.</b>
levels.level2.part3.about3=Let's start learning this operator with an example. \
  Suppose we have to find the maximum of two int variables, <code>a</code> and <code>b</code>. \
  It is easy to write using a conditional statement:
levels.level2.part3.about4=int a = ...;\n\
  int b = ...;\n\
  int max = ...;\n\
  \n\
  if (a > b) {\n\
  \tmax = a;\n\
  } else {\n\
  \tmax = b;\n\
  }
levels.level2.part3.about5=The equal ternary operator looks like:
levels.level2.part3.about6=int max = a > b ? a : b;
levels.level2.part3.about7=This code is more concise than the code above, isn't it?
levels.level2.part3.about8=The general syntax of the ternary operator is the following:
levels.level2.part3.about9=result = condition ? trueCase : elseCase;
levels.level2.part3.about10=It includes two special symbols <code>?</code> and <code>:</code>.
levels.level2.part3.about11=Here, the <code>condition</code> is a Boolean expression that evaluates \
  to either <code>true</code> or <code>false</code>. If this expression is <code>true</code>, \
  the ternary operator evaluates <code>trueCase</code>, otherwise <code>elseCase</code> is evaluated. \
  It is important that <code>trueCase</code> and <code>elseCase</code> are expressions which can be reduced \
  to a common type. This type determines the type of the <code>result</code>.
levels.level2.part3.about12=Let's consider another example that prints whether a number is even or odd.
levels.level2.part3.about13=int num = ...;  // it's initialized by a value\n\
  System.out.println(num % 2 == 0 ? "even" : "odd");
levels.level2.part3.about14=This ternary operator consists of three operands: the value of the expression \
  <code>num % 2 == 0</code>, and two string literals <code>"even"</code> and <code>"odd"</code>. \
  The result type of it is <code>String</code>.
levels.level2.part3.about15=Note, Java allows us to nest one ternary operator into another one, \
  but it can be less readable than the corresponding conditional statement. If you do this, be careful.
levels.level2.part3.task=Declare variables of type int <b>a</b>, <b>b</b> and <b>max</b> and assign a and b to \
  values​2 and 6. Using the ternary operator, assign the maximum value of the variables a and b to the variable max. \
  Display max.
levels.level2.part3.task.about=6
levels.level2.part3.task.error1=You have not declared the variable a!
levels.level2.part3.task.error2=You have not assigned a value to the variable a!
levels.level2.part3.task.error3=You have not declared the variable b!
levels.level2.part3.task.error4=You have not assigned a value to the variable b!
levels.level2.part3.task.error5=You have not declared the variable max!
levels.level2.part3.task.error6=You have not assigned a value to the variable max!
levels.level2.part3.task.error7=Do not change anything in main!
#part4
levels.level2.part4=Array
levels.level2.part4.introduction=Introduction to arrays
levels.level2.part4.introduction.about1=When you need to process multiple objects of the same type, \
  you can save them in an <b>array</b> and then process together as a single unit. \
  It is a very convenient approach if you do not know how many objects the program will process during runtime.
levels.level2.part4.introduction.about2=You may consider an <b>array</b> as a collection of elements of the same type. \
  All elements are stored in the memory sequentially.
levels.level2.part4.introduction.about3=The collection provides one name for its elements. \
  The possible number of elements to be stored is established when the array is created and cannot be changed. \
  But a stored element can be modified at any time.
levels.level2.part4.introduction.about4=The picture below illustrates an array of five floating-point numbers. \
  Each element has an integer index (0-4) to be accessed.
levels.level2.part4.introduction.about5=An array of five floating-point elements
levels.level2.part4.introduction.about6=Index
levels.level2.part4.introduction.about7=Element
levels.level2.part4.introduction.about8=The first element has the index 0, \
  the last element has the index equal array <b>size - 1</b>.
levels.level2.part4.introduction.about9=In Java, an array has the following important features:
levels.level2.part4.introduction.about10=an array is a reference type;
levels.level2.part4.introduction.about11=all array's elements are stored in the memory sequentially ;
levels.level2.part4.introduction.about12=each element of the array is accessed by its numerical index, \
  the first element has the <b>index 0</b>;
levels.level2.part4.introduction.about13=the last element is accessed by the index equal to <b>array size - 1</b>;
levels.level2.part4.introduction.about14=it is possible to create an array to store elements of any type.
levels.level2.part4.declaration=Declaration, instantiation, initialization
levels.level2.part4.declaration.about1=To create an array filled with elements we should:
levels.level2.part4.declaration.about2=declare a variable of an array type <b>(declaration)</b>;
levels.level2.part4.declaration.about3=create an instance of the array object <b>(instantiation)</b>;
levels.level2.part4.declaration.about4=initialize the array by some values <b>(initialization)</b>.
levels.level2.part4.declaration.about5=When we declare a variable, we define its type and name. \
  Instantiation happens when memory is allocated for this object. \
  Initializing of the array object means that we put the certain values of the array \
  object into the memory of our program.
levels.level2.part4.declaration.about6=To declare an array we must use two special characters [] \
  after the name of the type of elements in the array:
levels.level2.part4.declaration.about7=int[] array; // declaration's form 1
levels.level2.part4.declaration.about8=or after the name of an array variable:
levels.level2.part4.declaration.about9=int array[]; // declaration's form 2: less used in practice
levels.level2.part4.declaration.about10=Next, we will use the first form of declaration because \
  it is mostly used in practice.
levels.level2.part4.creating=Creating an array with the specified elements
levels.level2.part4.creating.about1=Java provides several ways to create an array with the specified elements.
levels.level2.part4.creating.about2=The simplest way to instantiate and initialize an array is to enumerate all \
  its elements:
levels.level2.part4.creating.about3=int[] numbers = { 1, 2, 3, 4 }; // instantiating and initializing an array \
  of 1, 2, 3, 4
levels.level2.part4.creating.about4=Another way is to initialize an array using variables:
levels.level2.part4.creating.about5=int a = 1, b = 2, c = 3, d = 4;\n\
  int[] numbers = { a, b, c, d }; // instantiating and initializing an array of 1, 2, 3, 4
levels.level2.part4.creating.about6=In this case, we should have all the elements at the moment of the array creation.
levels.level2.part4.new=Creating an array using the keyword "new"
levels.level2.part4.new.about1=The most general way to create an array is to use the special keyword <code>new</code> \
  and specify the necessary number of elements:
levels.level2.part4.new.about2=int n = ...; // n is a length of an array\n\
  int[] numbers = new int[n];
levels.level2.part4.new.about3=This form is useful when the number of elements is known before starting the program. \
  When we create an instance of the array object with indicated length like <code>[n]</code> or <code>[5]</code> \
  and don't enumerate its elements explicitly, the array is initialized with default values of its type.
levels.level2.part4.new.about4=Now, the array has <code>n</code> elements. \
  Each element is equal to zero (the default value of the type Int). \
  Next, we should make an explicit initialization of elements.
levels.level2.part4.new.about5=The size of an array cannot be greater than <code>Integer.MAX_VALUE</code>. \
  Actually, it is even slightly smaller than this value.
levels.level2.part4.new.about6=It's possible to separate declaration and instantiation in two lines:
levels.level2.part4.new.about7=int[] numbers; // declaration\n\
  numbers = new int[n]; // instantiation and initialization with default values
levels.level2.part4.new.about8=Also, we can write the keyword <code>new</code> and enumerate all elements of an array:
levels.level2.part4.new.about9=float[] floatNumbers; // declaration\n\
  floatNumbers = new float[] { 1.02f, 0.03f, 4f }; // instantiation and initialization
levels.level2.part4.length=The length of an array
levels.level2.part4.length.about1=To obtain the length of an existing array, access the special \
  property <code>arrayName.length</code>. Here is an example:
levels.level2.part4.length.about2=int[] array = { 1, 2, 3, 4 }; // an array of numbers\n\
  \n\
  int length = array.length; // number of elements of the array\n\
  \n\
  System.out.println(length); // 4
levels.level2.part4.elements=Accessing elements
levels.level2.part4.elements.about1=The values of elements of an array can be changed. \
  To set (get) a value to (from) array the index is used.
levels.level2.part4.elements.about2=Set the value by the index:
levels.level2.part4.elements.about3=array[index] = val;
levels.level2.part4.elements.about4=Get the value by the index
levels.level2.part4.elements.about5=val = array[index];
levels.level2.part4.elements.about6=Indexes of an array have numbers from <b>0</b> to <b>length - 1</b> inclusive.
levels.level2.part4.elements.about7=Let's see an example.
levels.level2.part4.elements.about8=int[] numbers = new int[3]; // numbers: [0, 0, 0]\n\
  numbers[0] = 1; // numbers: [1, 0, 0]\n\
  numbers[1] = 2; // numbers: [1, 2, 0]\n\
  numbers[2] = numbers[0] + numbers[1]; // numbers: [1, 2, 3]
levels.level2.part4.elements.about9=This code works as follow:
levels.level2.part4.elements.about10=in the first line, the array of integer named numbers with three elements \
  is created. It is initialized with default values, which is 0 for the int type;
levels.level2.part4.elements.about11=in the second line, the value "1" is assigned to the very first element of \
  the array by its index (do not forget, the first element has the index 0);
levels.level2.part4.elements.about12=in the third line, the value "2" is assigned to the second element of \
  the array by its index (numbers[1] - is the second element);
levels.level2.part4.elements.about13=in the last line, the sum of the first two elements is assigned to the third \
  element by its index.
levels.level2.part4.elements.about14=If we try to access a non-existing element by an index then a \
  runtime exception happens.
levels.level2.part4.elements.about15=For instance, let's try to get the fourth element (with index 3) \
  of the considered array <code>numbers</code>.
levels.level2.part4.elements.about16=int elem = numbers[3];
levels.level2.part4.elements.about17=The program throws <code>ArrayIndexOutOfBoundsException</code>.
levels.level2.part4.elements.about18=Be careful while indexing elements of an array.
levels.level2.part4.utility=The utility class Arrays
levels.level2.part4.utility.about1=If you need to process arrays, you can use standard methods grouped in the \
  utility class <code>Arrays</code>.
levels.level2.part4.utility.about2=convert array to string using <code>Arrays.toString(array)</code> and then print it:
levels.level2.part4.utility.about3=byte[] famousNumbers = { 0, 1, 2, 4, 8, 16, 32, 64 };\n\
  String arrayAsString = Arrays.toString(famousNumbers); // �[0, 1, 2, 4, 8, 16, 32, 64]\n\
  System.out.println(arrayAsString);
levels.level2.part4.utility.about4=sorting a whole array or a part of it using <code>Arrays.sort(array)</code>:
levels.level2.part4.utility.about5=long[] bigNumbers = { 200000000L, 400000000L, 100000000L, 300000000L }; // it's unsorted\n\
  \n\
  Arrays.sort(bigNumbers); // sorting whole array\n\
  \n\
  System.out.println(Arrays.toString(bigNumbers)); // [100000000, 200000000, 300000000, 400000000]
levels.level2.part4.utility.about6=comparing arrays: two arrays are equal if they contain the same \
  elements in the same order:
levels.level2.part4.utility.about7=int[] numbers1 = { 1, 2, 5, 8 };\n\
  int[] numbers2 = { 1, 2, 5 };\n\
  int[] numbers3 = { 1, 2, 5, 8 };\n\
  \n\
  System.out.println(Arrays.equals(numbers1, numbers2)); // it prints "false"\n\
  System.out.println(Arrays.equals(numbers1, numbers3)); // it prints "true"
levels.level2.part4.utility.about8=filling a whole array or a part of it by some values:
levels.level2.part4.utility.about9=int size = 10;\n\
  char[] characters = new char[size];\n\
  \n\
  // It takes an array, start index, end index (exclusive) and the value for filling the array\n\
  Arrays.fill(characters, 0, size / 2, 'A');\n\
  Arrays.fill(characters, size / 2, size, 'B');\n\
  \n\
  System.out.println(Arrays.toString(characters)); // it prints [A, A, A, A, A, B, B, B, B, B]
levels.level2.part4.utility.about10=Of course, the <code>Arrays</code> class contains a lot of other useful methods, \
  including array copying, search in arrays and so on.
levels.level2.part4.task=Declare an array <b>numbers1</b> and assign it { 100, 120, 200, 250 }. \
  Declare an array <b>numbers2</b> and assign it { 120, 100, 250, 200 }. \
  Using the utility of the Arrays class, compare 2 arrays and display the result.
levels.level2.part4.task.about=false
levels.level2.part4.task.error1=You did not declare an array of numbers1!
levels.level2.part4.task.error2=You have not declared the numbers2 array!
levels.level2.part4.task.error3=You have not compared 2 arrays!
levels.level2.part4.task.error4=Do not change anything in main!
#part5
levels.level2.part5=Processing strings
levels.level2.part5.about1=In some sense, a string looks like an array of characters. \
  Firstly, they both pertain to <b>sequences</b>. In addition, you can <b>iterate</b> both over strings and lists. \
  However, sometimes you need to turn a string into a list
levels.level2.part5.arrays=Strings and arrays
levels.level2.part5.arrays.about1=It's possible to convert between strings and character arrays using special methods:
levels.level2.part5.arrays.about2=char[] chars = { 'A', 'B', 'C', 'D', 'E', 'F' };\n\
  \n\
  String stringFromChars = String.valueOf(chars); // "ABCDEF"\n\
  \n\
  char[] charsFromString = stringFromChars.toCharArray(); // { 'A', 'B', 'C', 'D', 'E', 'F' }\n\
  \n\
  String theSameString = new String(charsFromString); // "ABCDEF"
levels.level2.part5.arrays.about3=There is another way to turn a string into an array. Take a look:
levels.level2.part5.arrays.about4=String text = "Hello";\n\
  String[] parts = text.split(""); // {"H", "e", "l", "l", "o"}
levels.level2.part5.arrays.about5=Here we used a much more concise method that splits a string into parts. \
  Let's consider it in more detail!
levels.level2.part5.splitting=Splitting the string
levels.level2.part5.splitting.about1=A string can be separated by delimiters to an array of strings. \
  To perform this, call the method <code>split</code>, it divides a string into substrings by a <b>separator</b>. \
  In the previous example, we used the <code>""</code> delimiter, which automatically splits a string \
  into the smallest elements: chars.
levels.level2.part5.splitting.about2=If the delimiter is specified, the method returns an array of all \
  the substrings and, notably, the delimiter itself is not included in any of the substrings:
levels.level2.part5.splitting.about3=String sentence = "a long text";\n\
  String[] words = sentence.split(" "); // {"a", "long", "text"}
levels.level2.part5.splitting.about4=Let's try to split an American phone number into country code, area code, \
  central office code, and other remaining digits:
levels.level2.part5.splitting.about5=String number = "+1-213-345-6789";\n\
  String[] parts = number.split("-"); // {"+1", "213", "345", "6789"}
levels.level2.part5.splitting.about6=Note that all the parts are still strings no matter how they look!
levels.level2.part5.splitting.about7=Choose your delimiter wisely, otherwise, you can receive some sentences \
  that start with a space:
levels.level2.part5.splitting.about8=String text = "That's one small step for a man, one giant leap for mankind.";\n\
  String[] parts = text.split(","); // {"That's one small step for a man", " one giant leap for mankind."}
levels.level2.part5.splitting.about9=You can choose any delimiter you prefer, even the combination of spaces and words:
levels.level2.part5.splitting.about10=String text = "I'm gonna be a programmer";\n\
  String[] parts = text.split(" gonna be "); // {"I'm", "a programmer"}
levels.level2.part5.splitting.about11=As you can see, the split method is also a good tool to get rid \
  of something you don't need or don't want to use.
levels.level2.part5.iterating=Iterating over a string
levels.level2.part5.iterating.about1=It's possible to iterate over characters of a string using a loop \
  <b>(while, do-while, for-loop)</b>.
levels.level2.part5.iterating.about2=See the following example.
levels.level2.part5.iterating.about3=String scientistName = "Isaac Newton";\n\
  \n\
  for (int i = 0; i < scientistName.length(); i++) {\n\
  \tSystem.out.print(scientistName.charAt(i) + " "); // print the current character\n\
  }
levels.level2.part5.iterating.about4=The code outputs:
levels.level2.part5.iterating.about5=I s a a c   N e w t o n
levels.level2.part5.iterating.about6=If you'd like to use the <b>for-each</b> loop, \
  first you should convert a string to an array of characters and iterate it.
levels.level2.part5.iterating.about7=String str = "strings are not primitive types!";\n\
  \n\
  int count = 0;\n\
  for (char ch : str.toCharArray()) {\n\
  \tif (Character.isWhitespace(ch)) {\n\
  \t\tcount++;\n\
  \t}\n\
  }\n\
  \n\
  System.out.println(count); // 4
levels.level2.part5.iterating.about8=The code above counts and prints the number of spaces in str. The result is 4.
#part6
levels.level2.part6=Iterating over arrays
levels.level2.part6.processing=Processing arrays using loops
levels.level2.part6.processing.about1=Often, it's needed to perform some kind of algorithms on the elements of an array. \
  For instance: sort them, find the maximum element, print only positive numbers, reverse the order, \
  calculate the arithmetic average of numbers and so on.
levels.level2.part6.processing.about2=A convenient way to process an array is to iterate over the array using a loop. \
  The property <code>length</code> of an array can help us to avoid <code>ArrayIndexOutOfBoundsException</code>.
levels.level2.part6.processing.about3=<b>Example 1.</b> Filling an array with the squares of indexes of its elements.
levels.level2.part6.processing.about4=int n = 10; // the size of an array\n\
  int[] squares = new int[n]; // creating an array with the specified size\n\
  \n\
  System.out.println(Arrays.toString(squares)); // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\
  \n\
  /* iterating over the array */\n\
  for (int i = 0; i < squares.length; i++) {\n\
  \tsquares[i] = i * i; // set the value by the element index\n\
  }\n\
  \n\
  System.out.println(Arrays.toString(squares)); // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
levels.level2.part6.processing.about5=In this code, an array with the size 10 and filled with zeros is created. \
  Then the value of each element of the array is set to the square of the element's index. \
  Then the program converts the array to the string representation (with square brackets) \
  and prints it to the standard output.
levels.level2.part6.processing.about6=<b>Example 2.</b> Checking the order of elements.
levels.level2.part6.processing.about7=The following program checks the given array is sorted ascending and prints "OK", \
  otherwise it prints "BROKEN".
levels.level2.part6.processing.about8=int[] numbers = { 1, 2, 3, 4, 5, 10, 6 }; // the order is broken\n\
  \n\
  boolean broken = false; // suppose the array is well-ordered\n\
  \n\
  /* iterating over the array */\n\
  for (int i = 1; i < numbers.length; i++) {\n\
  \n\
  \tif (numbers[i] < numbers[i - 1]) { // if the order is broken\n\
  \t\tbroken = true; // write a result\n\
  \t\tbreak;         // terminate the loop\n\
  \t}\n\
  }\n\
  \n\
  System.out.println(broken ? "BROKEN" : "OK");
levels.level2.part6.processing.about9=For the given array the program prints <code>"BROKEN"</code>.
levels.level2.part6.processing.about10=To iterate over arrays while and do-while loops are also admissible, \
  but they are used less often.
levels.level2.part6.reading=Reading an array from the standard input
levels.level2.part6.reading.about1=Using a loop we can read all elements of an array from the standard input.
levels.level2.part6.reading.about2=For example, the input consists of two lines. \
  The first line contains the length of an array, the second line - all elements of the array.
levels.level2.part6.reading.about3=5\n\
  101 102 504 302 881
levels.level2.part6.reading.about4=Let's read these numbers using the <code>Scanner</code> \
  (you can use another tool for reading) and then output all read numbers.
levels.level2.part6.reading.about5=import java.util.Scanner;\n\
  import java.util.Arrays;\n\
  \n\
  \n\
  public class ReadingArrayExample {\n\
  \n\
  \tpublic static void main(String args[]) {\n\
  \n\
  \t\tScanner scanner = new Scanner(System.in);\n\
  \n\
  \t\tint len = scanner.nextInt(); // reading a length\n\
  \t\tint[] array = new int[len];  // creating an array with the specified length\n\
  \n\
  \t\tfor (int i = 0; i < len; i++) {\n\
  \t\t\tarray[i] = scanner.nextInt(); // read the next number of the array\n\
  \t\t}\n\
  \t\tSystem.out.println(Arrays.toString(array)); // output the array\n\
  \t}\n\
  }
levels.level2.part6.reading.about6=The program outputs:
levels.level2.part6.reading.about7=[101, 102, 504, 302, 881]
levels.level2.part6.loop=Using for-each loop
levels.level2.part6.loop.about1=Since Java 5 there is a special form of the for-loop called for-each. \
  It is used to iterate through each element of an array, string or a collection \
  (we will learn them in next lessons) without indexes.
levels.level2.part6.loop.about2=Let's write code for calculating the number of <code>'a'</code> letters in the given \
  character array. To iterate over the array we'll use <b>for-each</b> loop.
levels.level2.part6.loop.about3=char[] characters = { 'a', 'b', 'c', 'a', 'b', 'c', 'a' };\n\
  \n\
  int counter = 0;\n\
  for (char ch : characters) {\n\
  \tif (ch == 'a') {\n\
  \t\tcounter++;\n\
  \t}\n\
  }\n\
  \n\
  System.out.println(counter); // it outputs "3"
levels.level2.part6.loop.about4=As you can see, the absence of indexes makes the code more readable. \
  It also allows you to avoid <code>ArrayIndexOutOfBoundsException</code>.
#part7
levels.level2.part7=Multi-dimensional array
levels.level2.part7.array=An array of arrays
levels.level2.part7.array.about1=Some structures such as matrices and tables are conveniently modeled by \
  two-dimensional arrays. Java provides a possibility to process two and more-dimensional arrays.
levels.level2.part7.array.about2=To create a multi-dimensional array we should use an array as an element \
  of another array In this case, we create an array of arrays.
levels.level2.part7.array.about3=To iterate through multi-dimensional arrays nested loops are often used.
levels.level2.part7.2dimensional=2-dimensional arrays
levels.level2.part7.2dimensional.about1=Here is an example that creates a two-dimensional array:
levels.level2.part7.2dimensional.about2=// two-dim array - the array of arrays\n\
  int[][] twoDimArray = {\n\
  \t{1, 2, 3, 1}, // first array of int\n\
  \t{3, 4, 1, 2}, // second array of int\n\
  \t{4, 4, 1, 0}  // third array of int\n\
  };
levels.level2.part7.2dimensional.about3=In this case, the length of <code>twoDimArray</code> is 3 \
  (because it includes 3 arrays as elements). The length of each nested array is 4.
levels.level2.part7.2dimensional.about4=Now if you'd like to get an integer element from \
  the array you should write two indexes:
levels.level2.part7.2dimensional.about5=int number = twoDimArray[0][2]; // it is 3
levels.level2.part7.2dimensional.about6=In this case, the first index specified an element (nested array or row) \
  of <code>twoDimArray</code>. The second index specified the element inside the nested array.
levels.level2.part7.2dimensional.about7=Important, all nested arrays can have a different length. See an example below:
levels.level2.part7.2dimensional.about8=int[][] twoDimArray = new int[3][];\n\
  \n\
  twoDimArray[0] = new int[] { 1, 2, 3, 4 }; // the length is 4\n\
  twoDimArray[1] = new int[] { 5, 7, 3};     // the length is 3\n\
  twoDimArray[2] = new int[] { 8 };          // the length is 1\n\
  \n\
  // let's output the array\n\
  for (int i = 0; i < twoDimArray.length; i++) {\n\
  \tSystem.out.println(Arrays.toString(twoDimArray[i]));\n\
  }
levels.level2.part7.2dimensional.about9=The code above outputs:
levels.level2.part7.2dimensional.about10=[1, 2, 3, 4]\n\
  [5, 7, 3]\n\
  [8]
levels.level2.part7.3dimensional=3-dimensional arrays
levels.level2.part7.3dimensional.about1=You can create an array with more than 2 dimensional\
   (<b>3-dim</b>, <b>4-dim</b>, <b>5-dim</b> and so on).
levels.level2.part7.3dimensional.about2=Let's create 3-dimensional of integers:
levels.level2.part7.3dimensional.about3=int[][][] cubic = new int[3][4][5];
levels.level2.part7.3dimensional.about4=Actually, this cubic array is represented as three 2-dimensional arrays 4x5.
levels.level2.part7.3dimensional.about5=Let's fill each 2D array of the cubic by the following rules:
levels.level2.part7.3dimensional.about6=the first 2D array must contain elements equal 1;
levels.level2.part7.3dimensional.about7=the second 2D array must contain elements equal 2;
levels.level2.part7.3dimensional.about8=the third 2D array must contain elements equal 3.
levels.level2.part7.3dimensional.about9=The classic way to do that is to use three <b>for</b> \
  loops: one outer loop and two nested.
levels.level2.part7.3dimensional.about10=int[][][] cubic = new int[3][4][5]; // an three-dimensiona array (cube)\n\
  \n\
  int current = 1; // it stores a value to fill elements\n\
  \n\
  for (int i = 0; i < 3; i++) { // iterating through each 2D array ("table" or "matrix")\n\
  \tfor (int j = 0; j < 4; j++) { // iterating through each 1D array ("vector") array of a "matrix"\n\
  \t\tfor (int k = 0; k < 5; k++) { // iterating through each element of a vector\n\
  \t\t\tcubic[i][j][k] = current; // assign a value to an element\n\
  \t\t}\n\
  \t}\n\
  \tcurrent++; // get the next value to the next "matrix"\n\
  }\n\
  \n\
  for (int i = 0; i < 3; i++) {\n\
  \tfor (int j = 0; j < 4; j++) {\n\
  \t\tfor (int k = 0; k < 5; k++) {\n\
  \t\t\tSystem.out.print(cubic[i][j][k] + " ");\n\
  \t\t}\n\
  \t\tSystem.out.println();\n\
  \t}\n\
  \tSystem.out.println();\n\
  }
levels.level2.part7.3dimensional.about11=This code prints
levels.level2.part7.3dimensional.about12=1 1 1 1 1\n\
  1 1 1 1 1\n\
  1 1 1 1 1\n\
  1 1 1 1 1\n\
  \n\
  2 2 2 2 2\n\
  2 2 2 2 2\n\
  2 2 2 2 2\n\
  2 2 2 2 2\n\
  \n\
  3 3 3 3 3\n\
  3 3 3 3 3\n\
  3 3 3 3 3\n\
  3 3 3 3 3
levels.level2.part7.3dimensional.about13=So, each 2D array (or "matrix") has its own value.
levels.level2.part7.3dimensional.about14=It is also possible to use <b>for-each</b> loop and methods of the \
  class <code>Arrays</code> to fill and print multidimensional arrays.
levels.level2.part7.3dimensional.about15=// this code fills the 3-dimensional array\n\
  int current = 1;\n\
  for (int[][] dim2Array : cubic) {     // for each 2-dim array\n\
  \tfor (int[] vector : dim2Array) {  // for each 1-dim array (vector) of 2-dim array\n\
  \t\tArrays.fill(vector, current); // fill the vector\n\
  \t}\n\
  \tcurrent++; // the next current\n\
  }\n\
  \n\
  // this code prints all 2-dimensional arrays\n\
  for (int[][] dim2Array : cubic) {\n\
  \tfor (int[] vector : dim2Array) {\n\
  \t\tSystem.out.println(Arrays.toString(vector));\n\
  \t}\n\
  \tSystem.out.println();\n\
  }
levels.level2.part7.3dimensional.about16=This code prints three 2-dim arrays:
levels.level2.part7.3dimensional.about17=[1, 1, 1, 1, 1]\n\
  [1, 1, 1, 1, 1]\n\
  [1, 1, 1, 1, 1]\n\
  [1, 1, 1, 1, 1]\n\
  \n\
  [2, 2, 2, 2, 2]\n\
  [2, 2, 2, 2, 2]\n\
  [2, 2, 2, 2, 2]\n\
  [2, 2, 2, 2, 2]\n\
  \n\
  [3, 3, 3, 3, 3]\n\
  [3, 3, 3, 3, 3]\n\
  [3, 3, 3, 3, 3]\n\
  [3, 3, 3, 3, 3]
#part8
levels.level2.part8=Overloading
levels.level2.part8.overloading=Methods overloading
levels.level2.part8.overloading.about1=Overloading allows you to change the method’s signature: the number \
  of parameters, their type or both. If methods have the same name, but a different number or type of parameters, \
  they are <b>overloaded</b>. It means you can invoke different methods by the same name by passing different arguments.
levels.level2.part8.overloading.about2=As an example, let's consider some overloaded method from the standard class \
  <code>Math</code>:
levels.level2.part8.overloading.about3=public static int abs(int a) { return (a < 0) ? -a : a; }\n\
  \n\
  public static float abs(float a) { return (a <= 0.0F) ? 0.0F - a : a; }
levels.level2.part8.overloading.about4=These methods have the same name but different type of the argument. \
  They are overloaded.
levels.level2.part8.overloading.about5=<b>Important</b> that it's impossible to declare more than one method with \
  the same name and parameters (number and types), even with different return types. \
  The return type is not considered for overloading because it's not a part of the signature.
levels.level2.part8.overloading.about6=Here are four methods print for printing different values.
levels.level2.part8.overloading.about7=public static void print(String stringToPrint) {\n\
  System.out.println(stringToPrint);\n\
  }\n\
  \n\
  public static void print(String stringToPrint, int times) {\n\
  \tfor (int i = 0; i < times; i++) {\n\
  \t\tSystem.out.println(stringToPrint);\n\
  \t}\n\
  }\n\
  \n\
  public static void print(int times, String stringToPrint) {\n\
  \tfor (int i = 0; i < times; i++) {\n\
  \t\tSystem.out.println(stringToPrint);\n\
  \t}\n\
  }\n\
  \n\
  public static void print(int val) {\n\
  \tSystem.out.println(val);\n\
  }
levels.level2.part8.overloading.about8=The first method prints an input string, the second and the \
  third ones print an input string a given number of times and the last one prints an integer value. \
  These methods are overloaded.
levels.level2.part8.overloading.about9=Let's invoke these methods:
levels.level2.part8.overloading.about10=print("some string");\n\
  print("another string", 2);\n\
  print(2, "another string again");\n\
  print(5);
levels.level2.part8.overloading.about11=As you can see, it's possible to call any of these methods by the same \
  name passing suitable arguments. The code outputs:
levels.level2.part8.overloading.about12=some string\n\
  another string\n\
  another string\n\
  another string again\n\
  another string again\n\
  5
levels.level2.part8.overloading.about13=Note, that changing the order of the same parameters is \
  a valid case of overloading.
levels.level2.part8.overloading.about14=The overloading mechanism allows us not to write different names for \
  methods that perform similar operations.
levels.level2.part8.overloading.about15=Looking ahead, we'll assume that overloading is a form of the static \
  (compile-time) polymorphism.
levels.level2.part8.casting=Overloading and casting
levels.level2.part8.casting.about1=In the case, where the type of a method parameter is not exactly the same as \
  the type of the passed argument, the compiler chooses the method that has the closest type of the \
  argument in order of the implicit casting.
levels.level2.part8.casting.about2=Let's see an example.
levels.level2.part8.casting.about3=public class OverloadingExample {\n\
  \n\
  \tpublic static void print(short a) {\n\
  \t\tSystem.out.println("short arg: " + a);\n\
  \t}\n\
  \n\
  \tpublic static void print(int a) {\n\
  \t\tSystem.out.println("int arg: " + a);\n\
  \t}\n\
  \n\
  \tpublic static void print(long a) {\n\
  \t\tSystem.out.println("long arg: " + a);\n\
  \t}\n\
  \n\
  \tpublic static void print(double a) {\n\
  \t\tSystem.out.println("double arg: " + a);\n\
  \t}\n\
  \n\
  \tpublic static void main(String[] args) {\n\
  \t\tprint(100);\n\
  \t}\n\
  }
levels.level2.part8.casting.about4=Let's call <code>print(100)</code>, the program outputs:
levels.level2.part8.casting.about5=int arg: 100
levels.level2.part8.casting.about6=Let's remove or comment the method <code>public static void print(int a)</code>, \
  then recompile and run the program again.
levels.level2.part8.casting.about7=The result is:
levels.level2.part8.casting.about8=long arg: 100
levels.level2.part8.casting.about9=Ok, now, let's remove the method <code>public static void print(long a)</code> too. \
  After recompiling the program outputs:
levels.level2.part8.casting.about10=double arg: 100.0
levels.level2.part8.casting.about11=If we remove the method <code>public static void print(double a)</code> \
  the program can't be compiled.
levels.level2.part8.casting.about12=In this way, the compiler chooses the most suitable method in the order of \
  implicit casting. If it's impossible we must cast an argument explicitly like in the following example:
levels.level2.part8.casting.about13=public class OverloadingExample {\n\
  \n\
  \tpublic static void print(short a) {\n\
  \t\tSystem.out.println("short arg: " + a);\n\
  \t}\n\
  \n\
  \tpublic static void main(String[] args) {\n\
  \t\tprint((short) 100);  // explicit casting\n\
  \t}\n\
  }
#part9
levels.level2.part9=Arrays as parameters
levels.level2.part9.passing=Passing arrays to methods
levels.level2.part9.passing.about1=A method can have parameters of any types including arrays, \
  strings, primitive types and so on.
levels.level2.part9.passing.about2=Here is an example, the method <code>processArray</code> has a single parameter \
  of the type <code>int[]</code>:
levels.level2.part9.passing.about3=public static void processArray(int[] array) { /* do something */ }
levels.level2.part9.passing.about4=In the body of the method, we can process the input array in any way.
levels.level2.part9.passing.about5=A parameter of an array type looks like a primitive type parameter. \
  But there is one important difference related to the fact that an array is a reference type.
levels.level2.part9.passing.about6=When you pass a value of a primitive type to a method, a copy of the value \
  is created. When you pass an array to a method, a copy of the reference is created but the value is the same. \
  It means if you change the actual value (elements of an array) in the body of a method, \
  you will see these changes outside the method.
levels.level2.part9.passing.about7=The following method swaps the first and the last elements of its parameter (array).
levels.level2.part9.passing.about8=public static void swapFirstAndLastElements(int[] nums) { // nums is an array\n\
  \tif (nums.length < 1) {\n\
  \t\treturn; // it returns nothing, i.e. just exits the method\n\
  \t}\n\
  \n\
  \tint temp = nums[nums.length - 1]; // save the last element in temporary local variable\n\
  \tnums[nums.length - 1] = nums[0];  // now, the last element is the first\n\
  \tnums[0] = temp;                   // now, the first element is the previous last\n\
  }
levels.level2.part9.passing.about9=Calling the method from the main method:
levels.level2.part9.passing.about10=public static void main(String[] args) {\n\
  \n\
  \tint[] numbers = { 1, 2, 3, 4, 5 }; // numbers\n\
  \n\
  \tSystem.out.println(Arrays.toString(numbers)); // before swapping\n\
  \n\
  \tswapFirstAndLastElements(numbers); // swapping\n\
  \n\
  \tSystem.out.println(Arrays.toString(numbers)); // after swapping\n\
  }
levels.level2.part9.passing.about11=The output is:
levels.level2.part9.passing.about12=[1, 2, 3, 4, 5]\n\
  [5, 2, 3, 4, 1]
levels.level2.part9.passing.about13=So, in the body of the main method, an array is visible as modified.
levels.level2.part9.varargs=Varargs
levels.level2.part9.varargs.about1=It's possible to pass an arbitrary number of the same type arguments to \
  a method using the special syntax named <b>varargs (variable-length arguments)</b>. \
  These arguments are specified by three dots after the type. In the body of the method, \
  you can process this parameter as a regular array of the specified type.
levels.level2.part9.varargs.about2=The following method takes an integer <b>vararg</b> parameter and outputs \
  the number of arguments in the standard output using the <b>length</b> property of arrays.
levels.level2.part9.varargs.about3=public static void printNumberOfArguments(int... numbers) {\n\
  \tSystem.out.println(numbers.length);\n\
  }
levels.level2.part9.varargs.about4=As you can see, here is a special syntax ... is used to specify \
  a <b>vararg</b> parameter.
levels.level2.part9.varargs.about5=Now, you can invoke the method passing several integer numbers or an array of ints.
levels.level2.part9.varargs.about6=printNumberOfArguments(1);\n\
  printNumberOfArguments(1, 2);\n\
  printNumberOfArguments(1, 2, 3);\n\
  printNumberOfArguments(new int[] { }); // no arguments here\n\
  printNumberOfArguments(new int[] { 1, 2 });
levels.level2.part9.varargs.about7=This code outputs:
levels.level2.part9.varargs.about8=1\n\
  2\n\
  3\n\
  0\n\
  2
levels.level2.part9.varargs.about9=This example also demonstrates the difference between the arguments and \
  parameters of a method. The method has only a single parameter but it can be called with several arguments.
levels.level2.part9.parameters=Varargs and other parameters
levels.level2.part9.parameters.about1=If a method has more than one parameter, a <code>vararg</code> parameter must \
  be the last parameter in the declaration of the method.
levels.level2.part9.parameters.about2=Here is an incorrect example:
levels.level2.part9.parameters.about3=public static void method(double... varags, int a) { /* do something */ }
levels.level2.part9.parameters.about4=The correct version of the method is:
levels.level2.part9.parameters.about5=public static void method(int a, double... varags) { /* do something */ }
#part10
levels.level2.part10=Errors in programs
levels.level2.part10.about1=Suppose, you're writing a Java program. \
  There are different errors that may occur during compiling or executing it. \
  We will divide all possible errors into two groups: <b>compile-time errors</b> and <b>run-time errors</b>.
levels.level2.part10.about2=Let's look at cases where the errors occur and how to avoid them.
levels.level2.part10.compile=Compile-time errors
levels.level2.part10.compile.about1=Compile-time errors is a class of errors which prevent a java program to compile:
levels.level2.part10.compile.about2=a syntax error: incorrect keyword, a forgotten symbol <code>;</code> \
  at the end of a statement;
levels.level2.part10.compile.about3=a bad source code file name;
levels.level2.part10.compile.about4=invoking a non-existing method;
levels.level2.part10.compile.about5=and many others.
levels.level2.part10.compile.about6=Consider an example of compile-time errors. \
  The following program should output the string <b>"Hello!"</b> but it does not compile.
levels.level2.part10.compile.about7=public class MyClass {\n\
  \n\
  \tpublic ztatic void main(String args[]) {\n\
  \t\tSystem.out.printn("Hello!");\n\
  \t}\n\
  }
levels.level2.part10.compile.about8=There are two errors in this program:
levels.level2.part10.compile.about9=a typo in the keyword <code>static</code>;
levels.level2.part10.compile.about10=incorrect name of the method <code>println</code>.
levels.level2.part10.compile.about11=If you fix these mistakes, it will be possible to compile this program.
levels.level2.part10.compile.about12=To avoid such errors, programmers use modern IDE \
  (Integrated Development Environment) with a static code analyzer. \
  This tool allows programmers to identify compile-time errors before the compilation. \
  In addition, it is able to highlight warning about more complex errors and weak places in your code, \
  as well as tips on how to improve the code.
levels.level2.part10.compile.about13=Over time, you will write code that contains less or even none of \
  the compile-time errors.
levels.level2.part10.run=Run-time errors
levels.level2.part10.run.about1=Run-time errors (also known as "bugs") are errors that occur when the program is \
  running. Run-time errors will cause your program to behave unexpectedly or may even stop the execution.
levels.level2.part10.run.about2=There are two subtypes of run-time errors:
levels.level2.part10.run.about3=<b>logic errors</b> – when a program produces a wrong result because the code is \
  not correct (for example, instead of <b>"Hello!"</b>, your program outputs <b>"Hi!"</b>);
levels.level2.part10.run.about4=<b>unhandled exceptional events</b> like division by zero, not found \
  files and other unexpected cases.
levels.level2.part10.run.about5=Avoiding such run-time errors is a more difficult task than avoiding \
  compile-time errors. If your program compiles successfully, there are no guarantees that it does not have bugs. \
  There are different strategies to find such errors:
levels.level2.part10.run.about6=to <b>debug</b> your program;
levels.level2.part10.run.about7=to write ﻿<b>automatic tests</b> for your program;
levels.level2.part10.run.about8=to use <b>code review</b> practice as part of ﻿the development process. \
  In general, this practice stands for a case, when﻿ one or more developers visually \
  inspect the source code of a program.