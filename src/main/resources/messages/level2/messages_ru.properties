#part1
levels.level2.part1=String
levels.level2.part1.string=Тип String
levels.level2.part1.string.about1=<code>String</code> это ссылочный тип, состоящий из символов. \
  Это один из наиболее широко используемых типов в Java. Вот пример строки: <code>"Hello, Java"</code>. \
  Эта строка представляет собой последовательность из 11 символов, включая один пробел.
levels.level2.part1.string.about2=Этот тип имеет некоторые особенности:
levels.level2.part1.string.about3=<b>неизменный тип</b>: невозможно изменить символ в строке;
levels.level2.part1.string.about4=у него есть методы для получения отдельных символов и извлечения подстрок;
levels.level2.part1.string.about5=отдельные символы могут быть доступны по индексам, \
  первый символ имеет индекс <b>0</b>, последний – <b>длина строки</b> – <b>1</b>;
levels.level2.part1.string.about6=непримитивный тип.
levels.level2.part1.createString=Создание строк
levels.level2.part1.createString.about1=Строковый литерал окружен парой двойных кавычек, например:
levels.level2.part1.createString.about2=String simpleString = "It is a simple string"; //простая строка\n\
  System.out.println(simpleString);  // выведет "It is a simple string"\n\
  \n\
  String anotherString = "This is\\na multiple\\nstring"; // строка с переносомами\n\
  System.out.println(anotherString); // выводит результат в несколько строк
levels.level2.part1.createString.about3=Строка может представлять длинную последовательность символов (текст). \
  Строка может содержать один или ноль символов.
levels.level2.part1.createString.about4=String strangeText = "aaaaaaaaaaaassssssssssss gggggggggggggggggggg ddddddddddd qqqqqq ffff";\n\
  \n\
  String emptyString = "";\n\
  \n\
  String s = "s"; // строка, состоящая из одного символа
levels.level2.part1.createString.about5=Строка может быть null. Это означает, что значение не назначено.
levels.level2.part1.createString.about6=String nullString = null; // null
levels.level2.part1.createString.about7=Другой способ создать переменную String использовать \
  ключевое слово <code>new</code>.
levels.level2.part1.createString.about8=String str = new String("my-string"); \
  //создает объект и присваивает его переменной
levels.level2.part1.length=Получить длину и символы строки
levels.level2.part1.length.about1=Любая строка имеет два полезных метода:
levels.level2.part1.length.about2=<code>length()</code> возвращает количество символов в строке;
levels.level2.part1.length.about3=<code>charAt(int index)</code>возвращает символ по его индексу;
levels.level2.part1.length.about4=Вот пример:
levels.level2.part1.length.about5=String s = "Hi, all";\n\
  \n\
  int len = s.length(); // длина 7\n\
  \n\
  char theFirstChar = s.charAt(0);  // 'H' имеет индекс 0\n\
  \n\
  char theFifthChar = s.charAt(4); // 'a' имеет индекс 4\n\
  \n\
  char theLastChar = s.charAt(s.length() - 1); // 'l' имеет индекс 6
levels.level2.part1.length.about6=Вы можете легко получить символ строки по индексу, \
  но вы не можете изменить символы, потому что строки являются неизменяемыми в Java.
levels.level2.part1.useful=Полезные методы строк
levels.level2.part1.useful.about1=Стандартная библиотека Java предоставляет множество полезных методов для обработки строк:
levels.level2.part1.useful.about2=<code>isEmpty()</code>возвращает <code>true</code> если строка пуста, \
  в противном случае – <code>false</code>;
levels.level2.part1.useful.about3=<code>toUpperCase()</code> возвращает новую строку в верхнем регистре;
levels.level2.part1.useful.about4=<code>toLowerCase()</code> возвращает новую строку в нижнем регистре;
levels.level2.part1.useful.about5=<code>startsWith(prefix)</code> возвращает <code>true</code> \
  если строка начинается с заданного префикса строки, в противном случае -<code>false</code>;
levels.level2.part1.useful.about6=<code>endsWith(suffix)</code> возвращает <code>true</code> \
  если строка заканчивается указанным суффиксом строки, в противном случае <code>false</code>.
levels.level2.part1.useful.about7=<code>contains(...)</code> возвращает true, если строка содержит данную строку или символ;
levels.level2.part1.useful.about8=<code>substring(beginIndex, endIndex)</code> возвращает подстроку строки в диапазоне: \
  <code>beginIndex</code>, <code>endIndex - 1</code>;
levels.level2.part1.useful.about9=<code>replace(old, new)</code> возвращает новую строку, полученную путем замены всех вхождений \
  <code>old</code> с <code>new</code> которые могут быть символами или строками.
levels.level2.part1.useful.about10=<code>trim()</code> возвращает копию строки, полученной пропуском \
  ведущие и конечные пробелы. Обратите внимание, что пробел включает в себя не только пробел, \
  но в основном все, что выглядит пустым: табуляция, возврат каретки, символ новой строки и т.д.
levels.level2.part1.useful.about11=Смотрите следующий пример, чтобы лучше понять эти методы:
levels.level2.part1.useful.about12=String text = "The simple text string";\n\
  \n\
  boolean empty = text.isEmpty(); // false\n\
  \n\
  String textInUpperCase = text.toUpperCase(); // "THE SIMPLE TEXT STRING"\n\
  \n\
  boolean startsWith = textInUpperCase.startsWith("THE"); // true\n\
  \n\
  /* заменить все пробелы на пустые строки */\n\
  \n\
  String noWhitespaces = textInUpperCase.replace(" ", ""); // "THESIMPLETEXTSTRING"\n\
  \n\
  String textWithWhitespaces = "\t text with whitespaces   !\n  \t";\n\
  \n\
  String trimmedText = textWithWhitespaces.trim(); // "text with whitespaces   !"
levels.level2.part1.exceptions=Исключения при обработке строк
levels.level2.part1.exceptions.about1=При работе со строками может быть несколько исключений.
levels.level2.part1.exceptions.about2=1. <code>NullPointerException</code>. \
  Если строка имеет значение <code>null</code> и вы вызываете метод этой строки, она генерирует исключение \
  <code>NullPointerException</code>.
levels.level2.part1.exceptions.about3=String s = null;\n\
  int length = s.length(); // выдаст NullPointerException
levels.level2.part1.exceptions.about4=2. <code>StringIndexOutOfBoundsException</code>. \
   Если вы пытаетесь получить доступ к несуществующему символу по индексу, возникает это исключение.
levels.level2.part1.exceptions.about5=String s = "ab";\n\
  char c = s.charAt(2); // выдаст StringIndexOutOfBoundsException  потому что индексация начинается с 0
levels.level2.part1.exceptions.about6=Мы рассмотрим, как обрабатывать различные типы исключений позже.
levels.level2.part1.concatenating=Объединяющие строки
levels.level2.part1.concatenating.about1=Две строки могут быть объединены с помощью оператора "+" \
  или метод <code>concat</code>. Оба подхода приводят к одинаковым результатам.
levels.level2.part1.concatenating.about2=String firstName = "John";\n\
  String lastName = "Smith";\n\
  \n\
  // конкатенация с использованием оператора "+"\n\
  String fullName1 = firstName + " " + lastName; // "John Smith"\n\
  \n\
  // конкатенация с использованием метода concat\n\
  String fullName2 = firstName.concat(" ").concat(lastName); // "John Smith"
levels.level2.part1.concatenating.about3=Когда мы объединяем две строки, создается новая строка \
  (потому что строки неизменяемы).
levels.level2.part1.concatenating.about4=Важно: в общем случае <code>str1 + str2</code> \
  не совпадает с <code>str2 + str1</code> потому что конкатенация не является коммутативной операцией.
levels.level2.part1.appending=Добавление значений в строку
levels.level2.part1.appending.about1=В строку можно добавлять значения разных типов. \
  Значение будет автоматически преобразовано в строку. Смотрите пример ниже.
levels.level2.part1.appending.about2=String str = "str" + 10 + false; // "str10false"
levels.level2.part1.appending.about3=В приведенном выше примере порядок выполнения:
levels.level2.part1.appending.about4="str" + 10 => "str10"
levels.level2.part1.appending.about5="str10" + false = "str10false"
levels.level2.part1.appending.about6=Давайте посмотрим на более сложный пример:
levels.level2.part1.appending.about7=String shortString = "str";\n\
  long number = 100;\n\
  \n\
  String result1 = shortString + number + 50; // "str10050"\n\
  String result2 = number + 50 + shortString; // каков result2?
levels.level2.part1.appending.about8=<code>result2</code> равно <code>150str</code>, потому что, во-первых, \
  мы вычисляем сумму <code>number</code> и <code>50</code>, а затем <code>concat</code> с помощью <code>str</code>. \
  Порядок операций важен.
levels.level2.part1.compare=Как правильно сравнивать строки?
levels.level2.part1.compare.about1=Поскольку <code>String</code> является ссылочным типом, вы не должны \
  сравнивать строки с использованием операторов <code>==</code> или <code>!=</code>. \
  В этом случае сравниваются только адреса, но не фактические значения.
levels.level2.part1.compare.about2=<code>String</code> имеет два удобных метода сравнения \
  эквивалентность фактического содержимого одной строки содержимому другой строки: \
  <code>equals(other)</code> и <code>equalsIgnoreCase(other)</code>. Смотрите пример ниже.
levels.level2.part1.compare.about3=String first = "first";\n\
  String second = "second";\n\
  \n\
  String anotherFirst = "first";\n\
  String secondInUpperCase = "SECOND";\n\
  \n\
  System.out.println(first.equals(second)); // false, строки имеют разные значения\n\
  System.out.println(first.equals(anotherFirst)); // true, строки имеют одинаковые значения\n\
  \n\
  System.out.println(second.equals(secondInUpperCase)); // false, строки имеют разные значения\n\
  System.out.println(second.equalsIgnoreCase(secondInUpperCase)); // true, игнорируется регистр
levels.level2.part1.compare.about4=Не забывайте правила при сравнении строк.
levels.level2.part1.task=Создайте строку <b>str</b> и присвойте ей значение "Java is the best!". \
  Выведете на экран 9 и 5 символ (помните, что индекс начинается с 0).
levels.level2.part1.task.about=hi
levels.level2.part1.task.error1=Вы не объявили строку str!
levels.level2.part1.task.error2=Вы не присвоили значение строке str!
levels.level2.part1.task.error3=Вы не выводите 9 символ!
levels.level2.part1.task.error4=Вы не выводите 5 символ!
levels.level2.part1.task.error5=Не меняйте ничего в main!
#part2
levels.level2.part2=Форматированный вывод
levels.level2.part2.introduction=Вступление
levels.level2.part2.introduction.about1=Вы уже знакомы с методами <code>System.out.print()</code> \
  и <code>System.out.println()</code> для вывода вывода на консоль. \
  Но когда вам нужно сложное <b>форматирование</b> вывода, эти два метода не очень полезны. \
  Есть два метода, которые вы можете использовать в таких случаях. \
  Это <code>System.out.printf()</code> и <code>String.format()</code>. \
  Давайте обсудим их подробно и сосредоточимся на форматировании строк и чисел.
levels.level2.part2.printf=Представляем метод printf()
levels.level2.part2.printf.about1=Метод <code>printf()</code> обычно состоит из двух частей. \
  Сначала вы даете строку, которую хотите отформатировать, в качестве первого атрибута. \
  Эта строка сама содержит правила для ее форматирования с помощью <b>спецификаторов формата</b>. \
  Некоторые примеры спецификаторов формата: <code>%d</code>, <code>%s</code> и т.д. \
  Во второй части вы даете список аргументов, который Java может использовать для форматирования строки \
  в соответствии со спецификаторами формата.
levels.level2.part2.printf.about2=Смотрите следующий пример, чтобы понять различные части  \
  функции <code>printf()</code>.
levels.level2.part2.printf.about3=System.out.printf("My Name is %s. I was born in %d", "Mike", 1998);
levels.level2.part2.printf.about4=Первая часть: <code>"My Name is %s. I was born in %d"</code>
levels.level2.part2.printf.about5=<code>%s</code> и <code>%d</code> являются спецификаторами формата.
levels.level2.part2.printf.about6=Вторая часть - это <code>"Mike",1998</code> представляющий собой список аргументов.
levels.level2.part2.use=Различные варианты использования printf()
levels.level2.part2.use.about1=Пришло время узнать различные варианты использования спецификаторов формата. \
  Это довольно легко понять с помощью примеров кода. Давайте попробуем.
levels.level2.part2.use.about2=Вы можете отобразить целое число с помощью спецификатора формата <code>%d</code>.
levels.level2.part2.use.about3=public static void main(String[] args){\n\
  \tSystem.out.printf("Display a Number %d", 15000);\n\
  }
levels.level2.part2.use.about4=Java заменит 15000 вместо <code>%d</code>. \
  Вывод вышеуказанного кода: <code>Display a Number 15000</code>
levels.level2.part2.use.about5=если вы хотите, чтобы в выводе отображалось несколько целых чисел, \
  используйте несколько спецификаторов <code>%d</code>.
levels.level2.part2.use.about6=public static void main(String[] args){\n\
  \tSystem.out.printf("Sum of %d and %d is %d", 15, 40, 55);\n\
  }
levels.level2.part2.use.about7=Java заменит каждый аргумент вместо <code>%d</code> соответственно, начиная слева. \
  Вывод приведенного выше кода <code>Sum of 15 and 40 is 55</code>
levels.level2.part2.use.about8=Если вы хотите отобразить значение с плавающей точкой, используйте спецификатор\
   <code>%f</code>.
levels.level2.part2.use.about9=public static void main(String[] args){\n\
  \tSystem.out.printf("Display a Number %f", 15.23);\n\
  }
levels.level2.part2.use.about10=Как и в приведенных выше случаях, Java заменит 15.23 вместо <code>%f</code>. \
  Приведенный выше код даст следующий вывод. <code>Display a Number 15.230000</code> \
  Хотя это технически правильно, это выглядит некрасиво. Вы не хотите так много конечных нулей. \
  Вы можете установить <b>точность</b> с помощью метода <code>printf()</code>.
levels.level2.part2.use.about11=public static void main(String[] args){\n\
  \tSystem.out.printf("Display a Number %.2f", 15.23);\n\
  }
levels.level2.part2.use.about12=<code>.2f</code> показывает, что количество цифр, которое \
  должно появиться после <b>десятичного числа</b> равно двум. \
  Приведенный выше код выведет <code>Display a Number 15.23</code>
levels.level2.part2.use.about13=Аналогичным образом вы можете отображать символы и строки с помощью метода \
  <code>printf()</code>. \
  Посмотрите на следующий код. Если вы хотите напечатать символ, используйте <code>%c</code> \
  и если вы хотите напечатать строку, используйте <code>%s</code>.
levels.level2.part2.use.about14=public static void main(String[] args){\n\
  \tchar abbr = 'H';\n\
  \tString element = "Hydrogen";\n\
  \tSystem.out.printf("%c stands for %s", abbr, element);\n\
  }
levels.level2.part2.use.about15=Когда этот код выполняется, значение <code>abbr</code> \
  переменная заменит <code>%c</code>, а значение <code>element</code> заменит <code>%s</code>. \
  Вывод вышеприведенного кода: <code>H stands for Hydrogen</code>. \
  Это все о методе <code>printf()</code>. Давайте перейдем к изучению метода <code>String.format()</code>.
levels.level2.part2.format=Метод String.format()
levels.level2.part2.format.about1=Метод <code>format()</code> в классе <code>String</code> \
  очень похож на метод <code>printf()</code>. \
  Основное отличие здесь в том, что вы возвращаете строку вместо ее печати. Давайте посмотрим на несколько примеров.
levels.level2.part2.format.about2=Следующий код форматирует целое число, используя его.
levels.level2.part2.format.about3=public static void main(String[] args){\n\
  \tint age = 22;\n\
  \tString str = String.format("My age is %d", age);\n\
  \tSystem.out.println(str);\n\
  }
levels.level2.part2.format.about4=Когда вы выполните этот код, Java создаст строку под названием <code>str</code> \
  конкатенируя <code>My age is</code> со значением переменной <code>age</code>. \
  Затем он напечатает значение <code>str</code>. Вывод:
levels.level2.part2.format.about5=My age is 22
levels.level2.part2.format.about6=Точно так же вы можете форматировать и другие типы данных. Смотрите следующий код.
levels.level2.part2.format.about7=public static void main(String[] args){\n\
  \tint age = 22;\n\
  \tchar initial = 'M';\n\
  \tString surname = "Anderson";\n\
  \tdouble height = 1.72;\n\
  \n\
  \tString details = String.format("My name is %c. %s.%nMy age is %d.%nMy height is %.2f.", initial, surname, age, height);\n\
  \tSystem.out.println(details);\n\
  }
levels.level2.part2.format.about8=Вы можете видеть, что мы использовали четыре типа данных в моем примере. \
  Java заменит <code>%c, %s, %d, %f</code> на <code>initial, surname, age</code>, \
  и <code>height</code> соответственно. <code>%n</code> переносит строку каждый раз, \
  когда он используется. Вывод нашего кода
levels.level2.part2.format.about9=My name is M. Anderson.\n\
  My age is 22.\n\
  My height is 1.72.
levels.level2.part2.summary=Суммируя
levels.level2.part2.summary.about1=Давайте подведем итоги, что мы узнали в этой теме.
levels.level2.part2.summary.about2=Спецификатор формата
levels.level2.part2.summary.about3=связанный тип данных
levels.level2.part2.summary.about4=Формат вывода
levels.level2.part2.summary.about5=Формат строки
levels.level2.part2.summary.about6=%d
levels.level2.part2.summary.about7=int, short, byte, long
levels.level2.part2.summary.about8=System.out.printf("Display a Integer %d",15000);
levels.level2.part2.summary.about9=String.format("Display a Integer %d",15000)
levels.level2.part2.summary.about10=%c
levels.level2.part2.summary.about11=char
levels.level2.part2.summary.about12=System.out.printf("Display a Character %c",'c');
levels.level2.part2.summary.about13=String.format("Display a Character %c",'c')
levels.level2.part2.summary.about14=%f
levels.level2.part2.summary.about15=double, float
levels.level2.part2.summary.about16=System.out.printf("Display a Floating-point Number %f",123.45);
levels.level2.part2.summary.about17=String.format("Display a Floating-point Number %f",123.45)
levels.level2.part2.summary.about18=%s
levels.level2.part2.summary.about19=String
levels.level2.part2.summary.about20=System.out.printf("Display a String %s","String");
levels.level2.part2.summary.about21=String.format("Display a String %s","String")
levels.level2.part2.conclusion=Заключение
levels.level2.part2.conclusion.about1=При написании сложных приложений комбинирование строк и переменных со знаком \
  <code>+</code> не рекомендуется. \
  Для этого специально созданы методы <code>printf()</code> и <code>format()</code>. \
  Оба эти метода работают точно так же, за исключением того, что метод <code>printf()</code> печатает выходные данные \
  в то время как метод <code>format()</code> возвращает <code>String</code>. \
  В этой статье вы узнали о большинстве вариантов использования обеих функций. Наслаждайся этим
levels.level2.part2.task=Объявите переменную <b>lvl</b> и присвойте ей значение 2. \
  Создайте строку <b>str</b> и присвойте ей значение "Мy level in java = 2" используя метод String.format(). \
  Выведете на экран str.
levels.level2.part2.task.about=Мy level in java = 2
levels.level2.part2.task.error1=Вы не объявили строку str!
levels.level2.part2.task.error2=Вы не присвоили значение строке str!
levels.level2.part2.task.error3=Вы не объявили переменную lvl!
levels.level2.part2.task.error4=Вы не присвоили значение переменной lvl!
levels.level2.part2.task.error5=Не меняйте ничего в main!
#part3
levels.level2.part3=Тернарный оператор
levels.level2.part3.about1=<b>Тернарный оператор</b> это оператор, который оценивает условие и выбирает один из \
  двух вариантов выполнения. Он также называется <b>условным оператором</b>. \
  Оператор может рассматриваться как форма оператора <code>if</code>-then-<code>else</code> statement. \
  Тернарный оператор не следует путать с условным утверждением, несмотря на их идеологическое сходство. \
  Этот оператор может использоваться в местах, где ожидается выражение.
levels.level2.part3.about2=Иногда <b>тернарный оператор</b> более читабелен и \
  лаконичен, чем соответствующий оператор <b>if</b>.
levels.level2.part3.about3=Давайте начнем изучать этот оператор с примера. \
  Предположим, нам нужно найти максимум две переменные типа <code>a</code> и <code>b</code>. \
  Это легко написать с помощью условного оператора:
levels.level2.part3.about4=int a = ...;\n\
  int b = ...;\n\
  int max = ...;\n\
  \n\
  if (a > b) {\n\
  \tmax = a;\n\
  } else {\n\
  \tmax = b;\n\
  }
levels.level2.part3.about5=Эквивалентный тернарный оператор выглядит так:
levels.level2.part3.about6=int max = a > b ? a : b;
levels.level2.part3.about7=Этот код более краткий, чем код выше, не так ли?
levels.level2.part3.about8=Общий синтаксис тернарного оператора следующий:
levels.level2.part3.about9=result = condition ? trueCase : elseCase;
levels.level2.part3.about10=Он содержит два специальных символа <code>?</code> и <code>:</code>.
levels.level2.part3.about11=Здесь <code>условие</code> является логическим выражением, которое вычисляет \
  либо <code>true</code> либо <code>false</code>. Если это выражение <code>true</code>, \
  тернарный оператор выбирает <code>trueCase</code>, в противном случае <code>elseCase</code>. \
  Важно, чтобы <code>trueCase</code> и <code>elseCase</code> были выражениями, которые можно привести к общему типу. \
  Этот тип определяет тип определяет тип <code>result</code>.
levels.level2.part3.about12=Давайте рассмотрим другой пример, который печатает, является ли число четным или нечетным.
levels.level2.part3.about13=int num = ...;  // num инициализируется значением\n\
  System.out.println(num % 2 == 0 ? "even" : "odd");
levels.level2.part3.about14=Этот тернарный оператор остоит из трех операндов: значения выражения  \
  <code>num % 2 == 0</code>, и двух строковых литералов <code>"even"</code> и <code>"odd"</code>. \
  Тип результата <code>String</code>.
levels.level2.part3.about15=Обратите внимание, Java позволяет нам вложить один тернарный оператор в другой, \
  но он может быть менее читаемым, чем соответствующий условный оператор. Если вы делаете это, будьте осторожны.
levels.level2.part3.task=Объявите переменные типа int <b>a</b>, <b>b</b> и <b>max</b> и присвойте a и b значения 2 и 6. \
  Используя тернарный оператор присвойте переменной max максимальное значение из переменных a и b. \
  Выведете на экран max.
levels.level2.part3.task.about=6
levels.level2.part3.task.error1=Вы не объявили переменную a!
levels.level2.part3.task.error2=Вы не присвоили значение переменной a!
levels.level2.part3.task.error3=Вы не объявили переменную b!
levels.level2.part3.task.error4=Вы не присвоили значение переменной b!
levels.level2.part3.task.error5=Вы не объявили переменную max!
levels.level2.part3.task.error6=Вы не присвоили значение переменной max!
levels.level2.part3.task.error7=Не меняйте ничего в main!
#part4
levels.level2.part4=Массив
levels.level2.part4.introduction=Введение в массивы
levels.level2.part4.introduction.about1=Когда вам нужно обработать несколько объектов одного типа, \
  вы можете сохранить их в <b>массиве</b>, а затем обрабатывать вместе как единое целое.  \
  Это очень удобный подход, если вы не знаете, сколько объектов программа обработает во время выполнения.
levels.level2.part4.introduction.about2=Вы можете рассматривать <b>массив</b> как набор элементов одного типа. \
  Все элементы хранятся в памяти последовательно.
levels.level2.part4.introduction.about3=Коллекция предоставляет одно имя для своих элементов. \
  Возможное количество элементов для хранения устанавливается при создании массива и не может быть изменено. \
  Но сохраненный элемент может быть изменен в любое время.
levels.level2.part4.introduction.about4=На рисунке ниже показан массив из пяти чисел с плавающей точкой. \
  Каждый элемент имеет целочисленный индекс (0-4) для доступа.
levels.level2.part4.introduction.about5=Массив из пяти элементов с плавающей точкой
levels.level2.part4.introduction.about6=Индекс
levels.level2.part4.introduction.about7=Элемент
levels.level2.part4.introduction.about8=Первый элемент имеет индекс 0, \
  последний элемент имеет индекс, равный массиву <b>размер - 1</b>.
levels.level2.part4.introduction.about9=В Java массив имеет следующие важные особенности:
levels.level2.part4.introduction.about10=массив является ссылочным типом;
levels.level2.part4.introduction.about11=все элементы массива хранятся в памяти последовательно;
levels.level2.part4.introduction.about12=каждый элемент массива доступен по его числовому индексу, \
  первый элемент имеет <b>индекс 0</b>;
levels.level2.part4.introduction.about13=последний элемент доступен по индексу, равному <b>размер массива - 1</b>;
levels.level2.part4.introduction.about14=можно создать массив для хранения элементов любого типа.
levels.level2.part4.declaration=Объявление, создание, инициализация
levels.level2.part4.declaration.about1=Чтобы создать массив, заполненный элементами, мы должны:
levels.level2.part4.declaration.about2=объявить переменную типа массива <b>(объявление)</b>;
levels.level2.part4.declaration.about3=создать экземпляр объекта массива <b>(создание)</b>;
levels.level2.part4.declaration.about4=инициализировать массив некоторыми значениями <b>(инициализация)</b>.
levels.level2.part4.declaration.about5=Когда мы объявляем переменную, мы определяем ее тип и имя.\
  Создание экземпляра происходит, когда для этого объекта выделяется память. \
  Инициализация объекта массива означает, что мы помещаем определенные значения объекта массива \
  в память нашей программы.
levels.level2.part4.declaration.about6=Чтобы объявить массив, мы должны использовать два специальных символа [] \
  после имени типа элементов в массиве:
levels.level2.part4.declaration.about7=int[] array; // форма декларации 1
levels.level2.part4.declaration.about8=или после имени переменной массива:
levels.level2.part4.declaration.about9=int array[]; // форма декларации 2: меньше используется на практике
levels.level2.part4.declaration.about10=Далее мы будем использовать первую форму объявления, потому что \
  это в основном используется на практике.
levels.level2.part4.creating=Создание массива с указанными элементами
levels.level2.part4.creating.about1=Java предоставляет несколько способов создания массива с указанными элементами.
levels.level2.part4.creating.about2=Самый простой способ создания и инициализации массива - это перечислить все \
  его элементы:
levels.level2.part4.creating.about3=int[] numbers = { 1, 2, 3, 4 }; // создание и инициализация массива \
  1, 2, 3, 4
levels.level2.part4.creating.about4=Другой способ - инициализировать массив с помощью переменных:
levels.level2.part4.creating.about5=int a = 1, b = 2, c = 3, d = 4;\n\
  int[] numbers = { a, b, c, d }; // создание и инициализация массива 1, 2, 3, 4
levels.level2.part4.creating.about6=В этом случае у нас должны быть все элементы на момент создания массива.
levels.level2.part4.new=Создание массива с использованием ключевого слова "new"
levels.level2.part4.new.about1=Самый общий способ создания массива - использовать специальное ключевое слово <code>new</code> \
  и укажите необходимое количество элементов:
levels.level2.part4.new.about2=int n = ...; // n длина массива\n\
  int[] numbers = new int[n];
levels.level2.part4.new.about3=Эта форма полезна, когда число элементов известно до запуска программы. \
  Когда мы создаем экземпляр объекта массива с указанной длиной, такой как <code>[n]</code> или <code>[5]</code> \
  и не перечислять его элементы явно, массив инициализируется значениями по умолчанию его типа.
levels.level2.part4.new.about4=Теперь в массиве есть элементы <code>n</code>. \
  Каждый элемент равен нулю (значение по умолчанию типа Int). \
  Далее мы должны сделать явную инициализацию элементов.
levels.level2.part4.new.about5=Размер массива не может быть больше, чем <code>Integer.MAX_VALUE</code>. \
  На самом деле, это даже немного меньше, чем это значение.
levels.level2.part4.new.about6=Можно разделить объявление и создание экземпляра в две строки:
levels.level2.part4.new.about7=int[] numbers; // объявление\n\
  numbers = new int[n]; // создание и инициализация со значениями по умолчанию
levels.level2.part4.new.about8=Также мы можем написать ключевое слово <code>new</code> и перечислить все элементы массива:
levels.level2.part4.new.about9=float[] floatNumbers; // объявление\n\
  floatNumbers = new float[] { 1.02f, 0.03f, 4f }; // создание и инициализация
levels.level2.part4.length=Длина массива
levels.level2.part4.length.about1=Чтобы получить длину существующего массива, обратитесь к специальному \
  свойству <code>arrayName.length</code>. Вот пример:
levels.level2.part4.length.about2=int[] array = { 1, 2, 3, 4 }; // массив чисел\n\
  \n\
  int length = array.length; // количество элементов массива\n\
  \n\
  System.out.println(length); // 4
levels.level2.part4.elements=Доступ к элементам
levels.level2.part4.elements.about1=Значения элементов массива могут быть изменены. \
  Для установки (получения) значения в (из) массива используется индекс.
levels.level2.part4.elements.about2=Установите значение по индексу:
levels.level2.part4.elements.about3=array[index] = val;
levels.level2.part4.elements.about4=Получить значение по индексу
levels.level2.part4.elements.about5=val = array[index];
levels.level2.part4.elements.about6=Индексы массива имеют номера от <b>0</b> до <b>длина - 1</b> включительно.
levels.level2.part4.elements.about7=Давайте посмотрим на пример.
levels.level2.part4.elements.about8=int[] numbers = new int[3]; // числа: [0, 0, 0]\n\
  numbers[0] = 1; // числа: [1, 0, 0]\n\
  numbers[1] = 2; // числа: [1, 2, 0]\n\
  numbers[2] = numbers[0] + numbers[1]; // числа: [1, 2, 3]
levels.level2.part4.elements.about9=Этот код работает следующим образом:
levels.level2.part4.elements.about10=в первой строке создается массив целых именованных чисел с тремя элементами. \
  Он инициализируется значениями по умолчанию, которые равны 0 для типа int;
levels.level2.part4.elements.about11=во второй строке значение "1" присваивается самому первому элементу \
  массива по его индексу (не забывайте, что первый элемент имеет индекс 0);
levels.level2.part4.elements.about12=в третьей строке значение "2" присваивается второму элементу \
  массива по его индексу (numbers [1] - это второй элемент);
levels.level2.part4.elements.about13=в последней строке сумма первых двух элементов присваивается третьему элементу \
  по его индексу.
levels.level2.part4.elements.about14=Если мы пытаемся получить доступ к несуществующему элементу по индексу, \
  возникает исключение во время выполнения.
levels.level2.part4.elements.about15=Например, давайте попробуем получить четвертый элемент (с индексом 3) \
  рассматриваемого массива <code>numbers</code>.
levels.level2.part4.elements.about16=int elem = numbers[3];
levels.level2.part4.elements.about17=Программа выдаст <code>ArrayIndexOutOfBoundsException</code>.
levels.level2.part4.elements.about18=Будьте осторожны при индексации элементов массива.
levels.level2.part4.utility=Утилита класса Arrays
levels.level2.part4.utility.about1=Если вам нужно обрабатывать массивы, вы можете использовать стандартные методы,  \
  сгруппированные в служебном классе <code>Arrays</code>.
levels.level2.part4.utility.about2=преобразовать массив в строку, используя <code>Arrays.toString(array)</code>, \
  а затем распечатать его:
levels.level2.part4.utility.about3=byte[] famousNumbers = { 0, 1, 2, 4, 8, 16, 32, 64 };\n\
  String arrayAsString = Arrays.toString(famousNumbers); // �[0, 1, 2, 4, 8, 16, 32, 64]\n\
  System.out.println(arrayAsString);
levels.level2.part4.utility.about4=сортировка всего массива или его части с помощью <code>Arrays.sort(array)</code>:
levels.level2.part4.utility.about5=long[] bigNumbers = { 200000000L, 400000000L, 100000000L, 300000000L }; // не отсортировано\n\
  \n\
  Arrays.sort(bigNumbers); // сортировка всего массива\n\
  \n\
  System.out.println(Arrays.toString(bigNumbers)); // [100000000, 200000000, 300000000, 400000000]
levels.level2.part4.utility.about6=Сравнение массивов: два массива равны, \
  если они содержат одинаковые элементы в одинаковом порядке:
levels.level2.part4.utility.about7=int[] numbers1 = { 1, 2, 5, 8 };\n\
  int[] numbers2 = { 1, 2, 5 };\n\
  int[] numbers3 = { 1, 2, 5, 8 };\n\
  \n\
  System.out.println(Arrays.equals(numbers1, numbers2)); // напечатает "false"\n\
  System.out.println(Arrays.equals(numbers1, numbers3)); // напечатает "true"
levels.level2.part4.utility.about8=заполнение всего массива или его части некоторыми значениями:
levels.level2.part4.utility.about9=int size = 10;\n\
  char[] characters = new char[size];\n\
  \n\
  // Он принимает массив, начальный индекс, конечный индекс (исключительный) и значение для заполнения массива\n\
  Arrays.fill(characters, 0, size / 2, 'A');\n\
  Arrays.fill(characters, size / 2, size, 'B');\n\
  \n\
  System.out.println(Arrays.toString(characters)); // напечатает [A, A, A, A, A, B, B, B, B, B]
levels.level2.part4.utility.about10=Конечно, класс <code>Arrays</code> содержит много других полезных методов, \
  включая копирование массивов, поиск в массивах и так далее.
levels.level2.part4.task=Объявите массив <b>numbers1</b> и присвойте ему { 100, 120, 200, 250 }. \
  Объявите массив <b>numbers2</b> и присвойте ему { 120, 100, 250, 200 }. \
  Используя утилиту класса Arrays сравните 2 массива и выведете результат на экран.
levels.level2.part4.task.about=false
levels.level2.part4.task.error1=Вы не объявили массив numbers1!
levels.level2.part4.task.error2=Вы не объявили массив numbers2!
levels.level2.part4.task.error3=Вы не сравнили 2 массива!
levels.level2.part4.task.error4=Не меняйте ничего в main!
#part5
levels.level2.part5=Обработка строк
levels.level2.part5.about1=В некотором смысле строка выглядит как массив символов. \
  Во-первых, они оба относятся к <b>последовательностям</b>. Кроме того, вы можете <b>перебирать</b> как строки, \
  так и списки. Однако иногда вам нужно превратить строку в список
levels.level2.part5.arrays=Строки и массивы
levels.level2.part5.arrays.about1=Конвертировать строки и символьные массивы можно с помощью специальных методов:
levels.level2.part5.arrays.about2=char[] chars = { 'A', 'B', 'C', 'D', 'E', 'F' };\n\
  \n\
  String stringFromChars = String.valueOf(chars); // "ABCDEF"\n\
  \n\
  char[] charsFromString = stringFromChars.toCharArray(); // { 'A', 'B', 'C', 'D', 'E', 'F' }\n\
  \n\
  String theSameString = new String(charsFromString); // "ABCDEF"
levels.level2.part5.arrays.about3=Есть еще один способ превратить строку в массив. Взглянуть:
levels.level2.part5.arrays.about4=String text = "Hello";\n\
  String[] parts = text.split(""); // {"H", "e", "l", "l", "o"}
levels.level2.part5.arrays.about5=Здесь мы использовали гораздо более краткий метод, который разбивает строку на части. \
  Давайте рассмотрим это более подробно!
levels.level2.part5.splitting=Расщепление строки
levels.level2.part5.splitting.about1=Строка может быть разделена разделителями на массив строк. \
  Для этого вызовите метод <code>split</code>, он разделяет строку на подстроки с помощью <b>разделителя</b>. \
  В предыдущем примере мы использовали разделитель <code>""</code>, который автоматически разбивает строку \
  на мельчайшие элементы: символы.
levels.level2.part5.splitting.about2=Если указан разделитель, метод возвращает массив всех подстрок, \
  и, в частности, сам разделитель не включен ни в одну из подстрок:
levels.level2.part5.splitting.about3=String sentence = "a long text";\n\
  String[] words = sentence.split(" "); // {"a", "long", "text"}
levels.level2.part5.splitting.about4=Давайте попробуем разбить американский номер телефона на код страны, \
  код города, код центрального офиса и другие оставшиеся цифры:
levels.level2.part5.splitting.about5=String number = "+1-213-345-6789";\n\
  String[] parts = number.split("-"); // {"+1", "213", "345", "6789"}
levels.level2.part5.splitting.about6=Обратите внимание, что все части все еще являются строками независимо от их внешнего вида!
levels.level2.part5.splitting.about7=Мудро выбирайте разделитель, в противном случае вы можете получить \
  предложения, начинающиеся с пробела:
levels.level2.part5.splitting.about8=String text = "That's one small step for a man, one giant leap for mankind.";\n\
  String[] parts = text.split(","); // {"That's one small step for a man", " one giant leap for mankind."}
levels.level2.part5.splitting.about9=Вы можете выбрать любой разделитель, который вы предпочитаете, \
  даже комбинацию пробелов и слов:
levels.level2.part5.splitting.about10=String text = "I'm gonna be a programmer";\n\
  String[] parts = text.split(" gonna be "); // {"I'm", "a programmer"}
levels.level2.part5.splitting.about11=Как видите, метод split также является хорошим инструментом для \
  избавления от того, что вам не нужно или не нужно использовать.
levels.level2.part5.iterating=Итерация по строке
levels.level2.part5.iterating.about1=Можно перебирать символы строки, используя цикл \
  <b>(while, do-while, for-loop)</b>.
levels.level2.part5.iterating.about2=Смотрите следующий пример.
levels.level2.part5.iterating.about3=String scientistName = "Isaac Newton";\n\
  \n\
  for (int i = 0; i < scientistName.length(); i++) {\n\
  \tSystem.out.print(scientistName.charAt(i) + " "); // напечает текущий символ\n\
  }
levels.level2.part5.iterating.about4=Код выводит:
levels.level2.part5.iterating.about5=I s a a c   N e w t o n
levels.level2.part5.iterating.about6=Если вы хотите использовать цикл <b>for-each</b>, \
  сначала вы должны преобразовать строку в массив символов и повторить ее.
levels.level2.part5.iterating.about7=String str = "strings are not primitive types!";\n\
  \n\
  int count = 0;\n\
  for (char ch : str.toCharArray()) {\n\
  \tif (Character.isWhitespace(ch)) {\n\
  \t\tcount++;\n\
  \t}\n\
  }\n\
  \n\
  System.out.println(count); // 4
levels.level2.part5.iterating.about8=Код выше подсчитывает и печатает количество пробелов в str. Результат 4.
#part6
levels.level2.part6=Перебор массивов
levels.level2.part6.processing=Обработка массивов с использованием циклов
levels.level2.part6.processing.about1=Часто необходимо выполнить какие-то алгоритмы для элементов массива. \
  Например: отсортировать их, найти максимальный элемент, вывести только положительные числа, изменить порядок, \
  вычислить среднее арифметическое чисел и так далее.
levels.level2.part6.processing.about2=Удобный способ обработки массива - это итерация по массиву с использованием цикла. \
  Свойство <code>длина</code> массива может помочь нам избежать <code>ArrayIndexOutOfBoundsException</code>.
levels.level2.part6.processing.about3=<b>Пример 1.</b> Заполнение массива квадратами индексов его элементов.
levels.level2.part6.processing.about4=int n = 10; // длина массива\n\
  int[] squares = new int[n]; // создание массива с указанным размером\n\
  \n\
  System.out.println(Arrays.toString(squares)); // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\
  \n\
  /* перебирая массив */\n\
  for (int i = 0; i < squares.length; i++) {\n\
  \tsquares[i] = i * i; // установить значение по индексу элемента\n\
  }\n\
  \n\
  System.out.println(Arrays.toString(squares)); // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
levels.level2.part6.processing.about5=В этом коде создается массив размером 10 и заполненный нулями. \
  Затем значение каждого элемента массива устанавливается равным квадрату индекса элемента. \
  Затем программа преобразует массив в строковое представление (в квадратных скобках) \
  и печатает его на стандартный вывод.
levels.level2.part6.processing.about6=<b>Пример 2..</b> Проверка порядка элементов.
levels.level2.part6.processing.about7=Следующая программа проверяет, что данный массив отсортирован по возрастанию, \
  и выдает "OK", в противном случае он печатает "BROKEN".
levels.level2.part6.processing.about8=int[] numbers = { 1, 2, 3, 4, 5, 10, 6 }; // порядок нарушен\n\
  \n\
  boolean broken = false; // предположим, что массив хорошо упорядочен\n\
  \n\
  /* перебирая массив */\n\
  for (int i = 1; i < numbers.length; i++) {\n\
  \n\
  \tif (numbers[i] < numbers[i - 1]) { // если порядок нарушен\n\
  \t\tbroken = true; // вывод результата\n\
  \t\tbreak;         // завершить цикл\n\
  \t}\n\
  }\n\
  \n\
  System.out.println(broken ? "BROKEN" : "OK");
levels.level2.part6.processing.about9=Для данного массива программа выводит <code>"BROKEN"</code>.
levels.level2.part6.processing.about10=Для перебора массивов циклы while и do-while также допустимы, \
  но они используются реже.
levels.level2.part6.reading=Чтение массива из стандартного ввода
levels.level2.part6.reading.about1=Используя цикл, мы можем прочитать все элементы массива из стандартного ввода.
levels.level2.part6.reading.about2=Например, вход состоит из двух строк. \
  Первая строка содержит длину массива, вторая строка - все элементы массива.
levels.level2.part6.reading.about3=5\n\
  101 102 504 302 881
levels.level2.part6.reading.about4=Давайте прочитаем эти цифры, используя <code>Scanner</code> \
  (вы можете использовать другой инструмент для чтения), а затем вывести все прочитанные числа.
levels.level2.part6.reading.about5=import java.util.Scanner;\n\
  import java.util.Arrays;\n\
  \n\
  \n\
  public class ReadingArrayExample {\n\
  \n\
  \tpublic static void main(String args[]) {\n\
  \n\
  \t\tScanner scanner = new Scanner(System.in);\n\
  \n\
  \t\tint len = scanner.nextInt(); // считываем длину\n\
  \t\tint[] array = new int[len];  // создаем массив\n\
  \n\
  \t\tfor (int i = 0; i < len; i++) {\n\
  \t\t\tarray[i] = scanner.nextInt(); // считать следующий элемент массива\n\
  \t\t}\n\
  \t\tSystem.out.println(Arrays.toString(array)); // вывести массив\n\
  \t}\n\
  }
levels.level2.part6.reading.about6=Программа выводит:
levels.level2.part6.reading.about7=[101, 102, 504, 302, 881]
levels.level2.part6.loop=Использование for-each цикла
levels.level2.part6.loop.about1=Начиная с Java 5 существует специальная форма цикла for, которая называется for-each. \
  Он используется для перебора каждого элемента массива, строки или коллекции \
  (мы выучим их на следующих уроках) без указателей.
levels.level2.part6.loop.about2=Давайте напишем код для расчета количества букв <code>'a'</code> letters in the given \
  в данном массиве символов. Для перебора массива мы будем использовать цикл <b>for-each</b>.
levels.level2.part6.loop.about3=char[] characters = { 'a', 'b', 'c', 'a', 'b', 'c', 'a' };\n\
  \n\
  int counter = 0;\n\
  for (char ch : characters) {\n\
  \tif (ch == 'a') {\n\
  \t\tcounter++;\n\
  \t}\n\
  }\n\
  \n\
  System.out.println(counter); // выведет "3"
levels.level2.part6.loop.about4=Как видите, отсутствие индексов делает код более читабельным. \
  Это также позволяет вам избежать <code>ArrayIndexOutOfBoundsException</code>.
#part7
levels.level2.part7=Многомерный массив
levels.level2.part7.array=Массив массивов
levels.level2.part7.array.about1=Некоторые структуры, такие как матрицы и таблицы, удобно моделируются с помощью \
  двумерных массивов. Java предоставляет возможность обрабатывать два и более многомерных массива.
levels.level2.part7.array.about2=Для создания многомерного массива мы должны использовать массив в качестве элемента \
  другого массива В этом случае мы создаем массив массивов.
levels.level2.part7.array.about3=Для перебора многомерных массивов часто используются вложенные циклы.
levels.level2.part7.2dimensional=2-мерные массивы
levels.level2.part7.2dimensional.about1=Вот пример, который создает двумерный массив:
levels.level2.part7.2dimensional.about2=// двумерный массив - массив массивов\n\
  int[][] twoDimArray = {\n\
  \t{1, 2, 3, 1}, // первый массив\n\
  \t{3, 4, 1, 2}, // второй массив\n\
  \t{4, 4, 1, 0}  // третий массив\n\
  };
levels.level2.part7.2dimensional.about3=В этом случае длина <code>twoDimArray</code> 3 \
  (потому что он включает в себя 3 массива в качестве элементов). Длина каждого вложенного массива равна 4.
levels.level2.part7.2dimensional.about4=Теперь, если вы хотите получить целочисленный элемент из массива, \
  вы должны написать два индекса:
levels.level2.part7.2dimensional.about5=int number = twoDimArray[0][2]; // 3
levels.level2.part7.2dimensional.about6=В этом случае в первом индексе указан элемент (вложенный массив или строка) \
  из <code>twoDimArray</code>. Второй индекс указывает элемент внутри вложенного массива.
levels.level2.part7.2dimensional.about7=Важно, что все вложенные массивы могут иметь разную длину. Смотрите пример ниже:
levels.level2.part7.2dimensional.about8=int[][] twoDimArray = new int[3][];\n\
  \n\
  twoDimArray[0] = new int[] { 1, 2, 3, 4 }; // длина 4\n\
  twoDimArray[1] = new int[] { 5, 7, 3};     // длина 3\n\
  twoDimArray[2] = new int[] { 8 };          // длина 1\n\
  \n\
  // вывод массива\n\
  for (int i = 0; i < twoDimArray.length; i++) {\n\
  \tSystem.out.println(Arrays.toString(twoDimArray[i]));\n\
  }
levels.level2.part7.2dimensional.about9=Код выше выводит:
levels.level2.part7.2dimensional.about10=[1, 2, 3, 4]\n\
  [5, 7, 3]\n\
  [8]
levels.level2.part7.3dimensional=3-мерные массивы
levels.level2.part7.3dimensional.about1=Вы можете создать массив более чем 2-х мерный\
   (<b>3-мерный</b>, <b>4-мерный</b>, <b>5-мерный</b> и т. д.).
levels.level2.part7.3dimensional.about2=Давайте создадим трехмерный массив чисел:
levels.level2.part7.3dimensional.about3=int[][][] cubic = new int[3][4][5];
levels.level2.part7.3dimensional.about4=На самом деле, этот кубический массив представлен в виде трех \
  двумерных массивов 4x5.
levels.level2.part7.3dimensional.about5=Давайте заполним каждый двумерный массив кубики по следующим правилам:
levels.level2.part7.3dimensional.about6=первый 2D массив должен содержать элементы, равные 1;
levels.level2.part7.3dimensional.about7=второй 2D массив должен содержать элементы, равные 2;
levels.level2.part7.3dimensional.about8=третий 2D массив должен содержать элементы, равные 3.
levels.level2.part7.3dimensional.about9=Классический способ сделать это - использовать три <b>for</b> \
  цикла: одна внешняя и две вложенные.
levels.level2.part7.3dimensional.about10=int[][][] cubic = new int[3][4][5]; // трехмерный массив (куб)\n\
  \n\
  int current = 1; // хранит значение для заполнения элементов\n\
  \n\
  for (int i = 0; i < 3; i++) { // итерация по каждому двумерному массиву («таблица» или «матрица»)\n\
  \tfor (int j = 0; j < 4; j++) { // перебирая каждый массив 1D ("вектор") "матрицы"\n\
  \t\tfor (int k = 0; k < 5; k++) { // перебирая каждый элемент вектора\n\
  \t\t\tcubic[i][j][k] = current; // присвоить значение элементу\n\
  \t\t}\n\
  \t}\n\
  \tcurrent++; // получить следующее значение для следующей "матрицы"\n\
  }\n\
  \n\
  for (int i = 0; i < 3; i++) {\n\
  \tfor (int j = 0; j < 4; j++) {\n\
  \t\tfor (int k = 0; k < 5; k++) {\n\
  \t\t\tSystem.out.print(cubic[i][j][k] + " ");\n\
  \t\t}\n\
  \t\tSystem.out.println();\n\
  \t}\n\
  \tSystem.out.println();\n\
  }
levels.level2.part7.3dimensional.about11=Этот код печатает
levels.level2.part7.3dimensional.about12=1 1 1 1 1\n\
  1 1 1 1 1\n\
  1 1 1 1 1\n\
  1 1 1 1 1\n\
  \n\
  2 2 2 2 2\n\
  2 2 2 2 2\n\
  2 2 2 2 2\n\
  2 2 2 2 2\n\
  \n\
  3 3 3 3 3\n\
  3 3 3 3 3\n\
  3 3 3 3 3\n\
  3 3 3 3 3
levels.level2.part7.3dimensional.about13=Итак, каждый двумерный массив (или «матрица») имеет свое значение.
levels.level2.part7.3dimensional.about14=Также можно использовать цикл <b>for-each</b> и методы класса \
  <code>Arrays</code> для заполнения и печати многомерных массивов.
levels.level2.part7.3dimensional.about15=// этот код заполняет трехмерный массив\n\
  int current = 1;\n\
  for (int[][] dim2Array : cubic) {     // для каждого 2-мерного массива\n\
  \tfor (int[] vector : dim2Array) {  // для каждого 1-мерного массива (вектора) 2-мерных массивов\n\
  \t\tArrays.fill(vector, current); // заполнить вектор\n\
  \t}\n\
  \tcurrent++;\n\
  }\n\
  \n\
  // этот код печатает все 2-мерные массивы\n\
  for (int[][] dim2Array : cubic) {\n\
  \tfor (int[] vector : dim2Array) {\n\
  \t\tSystem.out.println(Arrays.toString(vector));\n\
  \t}\n\
  \tSystem.out.println();\n\
  }
levels.level2.part7.3dimensional.about16=Этот код печатает три 2-мерных массива:
levels.level2.part7.3dimensional.about17=[1, 1, 1, 1, 1]\n\
  [1, 1, 1, 1, 1]\n\
  [1, 1, 1, 1, 1]\n\
  [1, 1, 1, 1, 1]\n\
  \n\
  [2, 2, 2, 2, 2]\n\
  [2, 2, 2, 2, 2]\n\
  [2, 2, 2, 2, 2]\n\
  [2, 2, 2, 2, 2]\n\
  \n\
  [3, 3, 3, 3, 3]\n\
  [3, 3, 3, 3, 3]\n\
  [3, 3, 3, 3, 3]\n\
  [3, 3, 3, 3, 3]
#part8
levels.level2.part8=Перегрузка
levels.level2.part8.overloading=Методы перегрузки
levels.level2.part8.overloading.about1=Перегрузка позволяет изменить сигнатуру метода: количество параметров, \
  их тип или оба. Если методы имеют одинаковое имя, но другое количество или тип параметров, \
  они <b>перегружены</b>. Это означает, что вы можете вызывать разные методы под одним и тем же именем, \
  передавая разные аргументы.
levels.level2.part8.overloading.about2=В качестве примера рассмотрим перегруженный метод из стандартного класса  \
  <code>Math</code>:
levels.level2.part8.overloading.about3=public static int abs(int a) { return (a < 0) ? -a : a; }\n\
  \n\
  public static float abs(float a) { return (a <= 0.0F) ? 0.0F - a : a; }
levels.level2.part8.overloading.about4=Эти методы имеют одинаковые имена, но разные типы аргументов. \
  Они перегружены.
levels.level2.part8.overloading.about5=<b>Важно</b> что невозможно объявить более одного метода с одинаковым именем \
  и параметрами (числом и типами), даже с разными типами возвращаемых данных. \
  Тип возвращаемого значения не рассматривается для перегрузки, поскольку он не является частью подписи.
levels.level2.part8.overloading.about6=Вот четыре способа печати для печати разных значений.
levels.level2.part8.overloading.about7=public static void print(String stringToPrint) {\n\
  System.out.println(stringToPrint);\n\
  }\n\
  \n\
  public static void print(String stringToPrint, int times) {\n\
  \tfor (int i = 0; i < times; i++) {\n\
  \t\tSystem.out.println(stringToPrint);\n\
  \t}\n\
  }\n\
  \n\
  public static void print(int times, String stringToPrint) {\n\
  \tfor (int i = 0; i < times; i++) {\n\
  \t\tSystem.out.println(stringToPrint);\n\
  \t}\n\
  }\n\
  \n\
  public static void print(int val) {\n\
  \tSystem.out.println(val);\n\
  }
levels.level2.part8.overloading.about8=Первый метод печатает входную строку, второй и третий выводят \
  входную строку заданное количество раз, а последний - целочисленное значение. Эти методы перегружены.
levels.level2.part8.overloading.about9=Давайте вызовем эти методы:
levels.level2.part8.overloading.about10=print("some string");\n\
  print("another string", 2);\n\
  print(2, "another string again");\n\
  print(5);
levels.level2.part8.overloading.about11=Как видите, любой из этих методов можно вызывать с одинаковым именем, \
  передавая подходящие аргументы. Код выводит:
levels.level2.part8.overloading.about12=some string\n\
  another string\n\
  another string\n\
  another string again\n\
  another string again\n\
  5
levels.level2.part8.overloading.about13=Обратите внимание, что изменение порядка тех же параметров\
  действительный случай перегрузки.
levels.level2.part8.overloading.about14=Механизм перегрузки позволяет нам не писать разные имена для методов, \
  которые выполняют похожие операции.
levels.level2.part8.overloading.about15=Забегая вперед, мы предположим, что перегрузка является \
  формой статического (компиляции) полиморфизма.
levels.level2.part8.casting=Перегрузка и привидение
levels.level2.part8.casting.about1=В случае, когда тип параметра метода не совсем совпадает с типом \
  передаваемого аргумента, компилятор выбирает метод, который имеет ближайший тип аргумента, \
  в порядке неявного приведения.
levels.level2.part8.casting.about2=Давайте посмотрим на пример.
levels.level2.part8.casting.about3=public class OverloadingExample {\n\
  \n\
  \tpublic static void print(short a) {\n\
  \t\tSystem.out.println("short arg: " + a);\n\
  \t}\n\
  \n\
  \tpublic static void print(int a) {\n\
  \t\tSystem.out.println("int arg: " + a);\n\
  \t}\n\
  \n\
  \tpublic static void print(long a) {\n\
  \t\tSystem.out.println("long arg: " + a);\n\
  \t}\n\
  \n\
  \tpublic static void print(double a) {\n\
  \t\tSystem.out.println("double arg: " + a);\n\
  \t}\n\
  \n\
  \tpublic static void main(String[] args) {\n\
  \t\tprint(100);\n\
  \t}\n\
  }
levels.level2.part8.casting.about4=Давайте вызовим <code>print(100)</code>, программа выведет:
levels.level2.part8.casting.about5=int arg: 100
levels.level2.part8.casting.about6=Давайте удалим или прокомментируем метод <code>public static void print(int a)</code>, \
  затем перекомпилируйте и снова запустите программу.
levels.level2.part8.casting.about7=Результат:
levels.level2.part8.casting.about8=long arg: 100
levels.level2.part8.casting.about9=Хорошо, теперь давайте удалим метод <code>public static void print(long a)</code>. \
  После перекомпиляции результатов программы:
levels.level2.part8.casting.about10=double arg: 100.0
levels.level2.part8.casting.about11=Если мы удалим метод <code>public static void print(double a)</code> \
  программа не может быть скомпилирована.
levels.level2.part8.casting.about12=Таким образом, компилятор выбирает наиболее подходящий метод в порядке неявного \
  приведения. Если это невозможно, мы должны явно привести аргумент, как в следующем примере:
levels.level2.part8.casting.about13=public class OverloadingExample {\n\
  \n\
  \tpublic static void print(short a) {\n\
  \t\tSystem.out.println("short arg: " + a);\n\
  \t}\n\
  \n\
  \tpublic static void main(String[] args) {\n\
  \t\tprint((short) 100);  // явное приведение\n\
  \t}\n\
  }
#part9
levels.level2.part9=Массивы как параметры
levels.level2.part9.passing=Передача массивов в методы
levels.level2.part9.passing.about1=Метод может иметь параметры любых типов, включая массивы, строки, типы примитивов \
  и т.д.
levels.level2.part9.passing.about2=Вот пример, метод <code>processArray</code> имеет единственный параметр типа \
  <code>int[]</code>:
levels.level2.part9.passing.about3=public static void processArray(int[] array) { /* делать что-нибудь */ }
levels.level2.part9.passing.about4=В теле метода мы можем обработать входной массив любым способом.
levels.level2.part9.passing.about5=Параметр типа массива выглядит как параметр типа примитива. \
  Но есть одно важное отличие, связанное с тем, что массив является ссылочным типом.
levels.level2.part9.passing.about6=Когда вы передаете значение типа примитива в метод, создается копия значения. \
  огда вы передаете массив методу, создается копия ссылки, но значение остается тем же. \
  Это означает, что если вы измените фактическое значение (элементы массива) в теле метода, \
  вы увидите эти изменения вне метода.
levels.level2.part9.passing.about7=Следующий метод меняет местами первый и последний элементы \
  своего параметра (массива).
levels.level2.part9.passing.about8=public static void swapFirstAndLastElements(int[] nums) { // nums это массив\n\
  \tif (nums.length < 1) {\n\
  \t\treturn; // он ничего не возвращает, т.е. просто выходит из метода\n\
  \t}\n\
  \n\
  \tint temp = nums[nums.length - 1]; // сохранить последний элемент во временной локальной переменной\n\
  \tnums[nums.length - 1] = nums[0];  // теперь последний элемент является первым\n\
  \tnums[0] = temp;                   // теперь первый элемент является последним\n\
  }
levels.level2.part9.passing.about9=Вызов метода из основного метода:
levels.level2.part9.passing.about10=public static void main(String[] args) {\n\
  \n\
  \tint[] numbers = { 1, 2, 3, 4, 5 }; // числа\n\
  \n\
  \tSystem.out.println(Arrays.toString(numbers)); // перед обменом\n\
  \n\
  \tswapFirstAndLastElements(numbers); // обмен\n\
  \n\
  \tSystem.out.println(Arrays.toString(numbers)); // после обмена\n\
  }
levels.level2.part9.passing.about11=Вывод:
levels.level2.part9.passing.about12=[1, 2, 3, 4, 5]\n\
  [5, 2, 3, 4, 1]
levels.level2.part9.passing.about13=Итак, в теле основного метода массив виден как измененный.
levels.level2.part9.varargs=Varargs
levels.level2.part9.varargs.about1=В метод можно передать произвольное число аргументов одного типа, \
  используя специальный синтаксис с именем <b>varargs (аргументы переменной длины)</b>. \
  Эти аргументы указываются тремя точками после типа. \
  В теле метода вы можете обработать этот параметр как обычный массив указанного типа.
levels.level2.part9.varargs.about2=Следующий метод принимает целочисленный параметр <b>vararg</b> \
  и выводит количество аргументов в стандартном выводе, используя свойство <b>длина</b> массива.
levels.level2.part9.varargs.about3=public static void printNumberOfArguments(int... numbers) {\n\
  \tSystem.out.println(numbers.length);\n\
  }
levels.level2.part9.varargs.about4=Как видите, здесь есть специальный синтаксис ... \
  используется для указания параметра <b>vararg</b>.
levels.level2.part9.varargs.about5=Теперь вы можете вызывать метод, передавая несколько целых \
  чисел или массив целых чисел.
levels.level2.part9.varargs.about6=printNumberOfArguments(1);\n\
  printNumberOfArguments(1, 2);\n\
  printNumberOfArguments(1, 2, 3);\n\
  printNumberOfArguments(new int[] { }); // нет аргументов\n\
  printNumberOfArguments(new int[] { 1, 2 });
levels.level2.part9.varargs.about7=Этот код выводит:
levels.level2.part9.varargs.about8=1\n\
  2\n\
  3\n\
  0\n\
  2
levels.level2.part9.varargs.about9=Этот пример также демонстрирует разницу между аргументами и параметрами метода. \
  Метод имеет только один параметр, но его можно вызывать с несколькими аргументами.
levels.level2.part9.parameters=Varargs и другие параметры
levels.level2.part9.parameters.about1=Если метод имеет более одного параметра, параметр <code>vararg</code> \
  должен быть последним параметром в объявлении метода.
levels.level2.part9.parameters.about2=Вот неправильный пример:
levels.level2.part9.parameters.about3=public static void method(double... varags, int a) { /* do something */ }
levels.level2.part9.parameters.about4=Правильная версия метода:
levels.level2.part9.parameters.about5=public static void method(int a, double... varags) { /* do something */ }
#part10
levels.level2.part10=Ошибки в программах
levels.level2.part10.about1=Предположим, вы пишете программу на Java. \
  Во время компиляции или выполнения могут возникнуть разные ошибки. \
  Мы разделим все возможные ошибки на две группы: <b>ошибки время компиляции</b> и <b>ошибки время выполнения</b>.
levels.level2.part10.about2=Давайте рассмотрим случаи, когда возникают ошибки и как их избежать.
levels.level2.part10.compile=Ошибки во время компиляции
levels.level2.part10.compile.about1=Ошибки время компиляции - это класс ошибок, которые мешают Java-программе компилироваться:
levels.level2.part10.compile.about2=синтаксическая ошибка: неверное ключевое слово, забытый символ <code>;</code> \
  в конце;
levels.level2.part10.compile.about3=неверное имя файла исходного кода;
levels.level2.part10.compile.about4=вызов несуществующего метода;
levels.level2.part10.compile.about5=и много других.
levels.level2.part10.compile.about6=Рассмотрим пример ошибок времени компиляции. \
  Следующая программа должна вывести строку <b>"Hello!"</b> , но она не скомпилируется.
levels.level2.part10.compile.about7=public class MyClass {\n\
  \n\
  \tpublic ztatic void main(String args[]) {\n\
  \t\tSystem.out.printn("Hello!");\n\
  \t}\n\
  }
levels.level2.part10.compile.about8=В этой программе есть две ошибки:
levels.level2.part10.compile.about9=опечатка в ключевом слове<code>static</code>;
levels.level2.part10.compile.about10=неверное имя метода <code>println</code>.
levels.level2.part10.compile.about11=Если вы исправите эти ошибки, можно будет скомпилировать эту программу.
levels.level2.part10.compile.about12=Чтобы избежать таких ошибок, программисты используют современную IDE \
  (Интегрированная среда разработки) со статическим анализатором кода. \
  Этот инструмент позволяет программистам выявлять ошибки во время компиляции перед компиляцией. \
  Кроме того, он может выделить предупреждение о более сложных ошибках и слабых местах в вашем коде, \
  а также советы о том, как улучшить код.
levels.level2.part10.compile.about13=Со временем вы напишите код, который содержит меньше \
  или даже не содержит ошибок времени компиляции.
levels.level2.part10.run=Ошибки во время выполнения
levels.level2.part10.run.about1=Ошибки время выполнения (также известные как «баги») - это ошибки, \
  возникающие во время работы программы. шибки во время выполнения могут привести к непредсказуемому \
  поведению вашей программы или даже к остановке выполнения.
levels.level2.part10.run.about2=Существует два подтипа ошибок времени выполнения:
levels.level2.part10.run.about3=<b>логические ошибки</b> – когда программа выдает неправильный результат \
  из-за неправильного кода (например, вместо <b>"Hello!"</b>, ваша программа выдает <b>"Hi!"</b>);
levels.level2.part10.run.about4=<b>необработанные исключительные события</b> такие как деление на ноль, \
  не найденные файлы и другие неожиданные случаи.
levels.level2.part10.run.about5=Избежать таких ошибок во время выполнения - \
  более сложная задача, чем избежать ошибок во время компиляции. \
  Если ваша программа успешно скомпилирована, нет никаких гарантий, что в ней нет ошибок. \
  Существуют разные стратегии поиска таких ошибок:
levels.level2.part10.run.about6=<b>отладить</b> вашу программу;
levels.level2.part10.run.about7=написать ﻿<b>автоматические тесты</b> для вашей программы;
levels.level2.part10.run.about8=использовать <b>проверку кода</b> как часть процесса разработки. \
  В целом, эта практика означает случай, \
  когда один или несколько разработчиков визуально проверяют исходный код программы.